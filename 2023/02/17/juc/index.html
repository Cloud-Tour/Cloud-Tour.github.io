<!DOCTYPE html>
<html lang=en>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>juc | Hexo</title>
  <meta name="description" content="1.进程和线程 进程  进程就是用来加载指令、管理内存、管理 IO 的 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。  线程  一个进程之内可以分为一到多个线程。 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器  区">
<meta property="og:type" content="article">
<meta property="og:title" content="juc">
<meta property="og:url" content="http://cloud-tour.github.io/2023/02/17/juc/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.进程和线程 进程  进程就是用来加载指令、管理内存、管理 IO 的 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。  线程  一个进程之内可以分为一到多个线程。 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器  区">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213132614988.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213132639252.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213132702541.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213133120665.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213135229761.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213135248243.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213135309641.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213135350177.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213135421083.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213140303379.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213140331233.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213140510345.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213140526827.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213141342962.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213142224159.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213144544684.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213144600483.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213145417995.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213145501204.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213145543910.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213145558046.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213145626572.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213150843395.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213150941238.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213151537230.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213151548031.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213151556253.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213152200757.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213152226734.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213152248771.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213152300864.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213152322187.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213152340898.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213152358996.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213161108770.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213163448999.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213163530988.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213163840871.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213165241399.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/AQS%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/AQS-%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/AQS-%E5%85%A5%E9%98%9F%E8%BF%87%E7%A8%8B%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/AQS-%E5%85%A5%E9%98%9F%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/AQS-%E5%87%BA%E9%98%9F%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/AQS-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/AQS-CHL%E9%98%9F%E5%88%97%E5%8F%82%E4%B8%8E%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/%E7%8B%AC%E5%8D%A0%E9%94%81(Exclusive)%E6%A8%A1%E5%BC%8F.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/%E5%85%B1%E4%BA%AB%E9%94%81(Share)%E6%A8%A1%E5%BC%8F.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213212816669.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213212834190.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213212927453.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213212945122.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/cc4383cf5f5043d79feb662bf6b0ef13.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS2lkZHl1cA==,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8f296c0d74594c369784d61fb440cb74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS2lkZHl1cA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5b31435597474878b570662cabf940b3.png">
<meta property="article:published_time" content="2023-02-17T13:02:02.380Z">
<meta property="article:modified_time" content="2023-02-17T13:11:55.182Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java">
<meta property="article:tag" content="juc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cloud-tour.github.io/2023/02/17/juc/image-20230213132614988.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://cloud-tour.github.io/2023/02/17/juc/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/Cloud-Tour" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar2.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Cloud-Tour</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Development Engineer &amp; Java</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> MaoMing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">Repository</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">Books</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">Links</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">About</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Cloud-Tour" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/">51单片机</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javase/">javase</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/juc/">juc</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm/">jvm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/debian/" rel="tag">debian</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java11/" rel="tag">java11</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/" rel="tag">juc</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/" rel="tag">jvm</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keil/" rel="tag">keil</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/proteus/" rel="tag">proteus</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssb/" rel="tag">ssb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssm/" rel="tag">ssm</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/debian/" style="font-size: 13.5px;">debian</a> <a href="/tags/java/" style="font-size: 14px;">java</a> <a href="/tags/java11/" style="font-size: 13px;">java11</a> <a href="/tags/juc/" style="font-size: 13.5px;">juc</a> <a href="/tags/jvm/" style="font-size: 13.5px;">jvm</a> <a href="/tags/kafka/" style="font-size: 13px;">kafka</a> <a href="/tags/keil/" style="font-size: 13px;">keil</a> <a href="/tags/mysql/" style="font-size: 13px;">mysql</a> <a href="/tags/nginx/" style="font-size: 13px;">nginx</a> <a href="/tags/proteus/" style="font-size: 13px;">proteus</a> <a href="/tags/redis/" style="font-size: 13px;">redis</a> <a href="/tags/ssb/" style="font-size: 13px;">ssb</a> <a href="/tags/ssm/" style="font-size: 13px;">ssm</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/kafka/">kafka</a>
              </p>
              <p class="item-title">
                <a href="/2023/03/09/kafka/" class="title">Kafka</a>
              </p>
              <p class="item-date">
                <time datetime="2023-03-09T10:19:44.444Z" itemprop="datePublished">2023-03-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/java/">java</a>
              </p>
              <p class="item-title">
                <a href="/2023/03/07/%E5%9F%BA%E7%A1%80/" class="title">基础</a>
              </p>
              <p class="item-date">
                <time datetime="2023-03-07T10:42:48.718Z" itemprop="datePublished">2023-03-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/redis/">redis</a>
              </p>
              <p class="item-title">
                <a href="/2023/02/17/redis/" class="title">redis</a>
              </p>
              <p class="item-date">
                <time datetime="2023-02-17T13:22:50.541Z" itemprop="datePublished">2023-02-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/mysql/">mysql</a>
              </p>
              <p class="item-title">
                <a href="/2023/02/17/mysql/" class="title">mysql</a>
              </p>
              <p class="item-date">
                <time datetime="2023-02-17T13:21:00.159Z" itemprop="datePublished">2023-02-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/java/">java</a>
              </p>
              <p class="item-title">
                <a href="/2023/02/17/ssb/" class="title">ssb</a>
              </p>
              <p class="item-date">
                <time datetime="2023-02-17T13:19:19.502Z" itemprop="datePublished">2023-02-17</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text"> 1.进程和线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2synchronized%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text"> 2.synchronized原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#monitor"><span class="toc-number">2.1.</span> <span class="toc-text"> Monitor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">2.2.</span> <span class="toc-text"> 轻量级锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E8%86%A8%E8%83%80"><span class="toc-number">2.3.</span> <span class="toc-text"> 锁膨胀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96"><span class="toc-number">2.4.</span> <span class="toc-text"> 自旋优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">2.5.</span> <span class="toc-text"> 偏向锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3wait-notify%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text"> 3.wait、notify原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4park-unpark-%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text"> 4.park unpark 原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5reentrantlock"><span class="toc-number">5.</span> <span class="toc-text"> 5.ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.</span> <span class="toc-text"> 条件变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text"> 非公平锁实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text"> 可重入原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.4.</span> <span class="toc-text"> 条件变量实现原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6volatile%E5%8E%9F%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text"> 6.volatile原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text"> 保证可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text"> 保证有序性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.</span> <span class="toc-text"> 7.线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-number">7.1.</span> <span class="toc-text"> 线程池状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text"> 工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text"> 构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-number">7.4.</span> <span class="toc-text"> 工作队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newfixedthreadpool"><span class="toc-number">7.5.</span> <span class="toc-text"> newFixedThreadPool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newcachedthreadpool"><span class="toc-number">7.6.</span> <span class="toc-text"> newCachedThreadPool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newsinglethreadexecutor"><span class="toc-number">7.7.</span> <span class="toc-text"> newSingleThreadExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4"><span class="toc-number">7.8.</span> <span class="toc-text"> 任务提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.9.</span> <span class="toc-text"> 关闭线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.10.</span> <span class="toc-text"> 任务调度线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forkjoin"><span class="toc-number">7.11.</span> <span class="toc-text"> Fork&#x2F;Join</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8aqs"><span class="toc-number">8.</span> <span class="toc-text"> 8.AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">8.1.</span> <span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">8.2.</span> <span class="toc-text"> 例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clh%E9%98%9F%E5%88%97"><span class="toc-number">8.3.</span> <span class="toc-text"> CLH队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">8.4.</span> <span class="toc-text"> 流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="toc-number">8.5.</span> <span class="toc-text"> 共享方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#state%E6%9C%BA%E5%88%B6"><span class="toc-number">8.6.</span> <span class="toc-text"> state机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9semaphore"><span class="toc-number">9.</span> <span class="toc-text"> 9.Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-2"><span class="toc-number">9.1.</span> <span class="toc-text"> 流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-countdownlatch"><span class="toc-number">10.</span> <span class="toc-text"> 10. CountDownLatch</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11cyclicbarrier"><span class="toc-number">11.</span> <span class="toc-text"> 11.CyclicBarrier</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">12.</span> <span class="toc-text"> 12.多线程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1"><span class="toc-number">12.1.</span> <span class="toc-text"> 通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C"><span class="toc-number">12.2.</span> <span class="toc-text"> 线程协作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sleepyieldjoin"><span class="toc-number">12.2.1.</span> <span class="toc-text"> sleep&#x2F;yield&#x2F;join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#waitnotifynotifyall"><span class="toc-number">12.2.2.</span> <span class="toc-text"> wait&#x2F;notify&#x2F;notifyAll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awaitsignalsignalall"><span class="toc-number">12.2.3.</span> <span class="toc-text"> await&#x2F;signal&#x2F;signalAll</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13threadlocal"><span class="toc-number">13.</span> <span class="toc-text"> 13.ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">13.1.</span> <span class="toc-text"> 原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%BC%82%E6%AD%A5%E4%BC%A0%E5%8F%82"><span class="toc-number">14.</span> <span class="toc-text"> 14.线程间异步传参</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text"> 15.进程间的通信方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">16.</span> <span class="toc-text"> 16.其他问题</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-juc" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      juc
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2023/02/17/juc/" class="article-date">
	  <time datetime="2023-02-17T13:02:02.380Z" itemprop="datePublished">2023-02-17</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/juc/">juc</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/java/" rel="tag">java</a>, <a class="article-tag-link-link" href="/tags/juc/" rel="tag">juc</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2023/02/17/juc/#comments" class="article-comment-link">Comments</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="1进程和线程"><a class="markdownIt-Anchor" href="#1进程和线程"></a> 1.进程和线程</h1>
<p><strong>进程</strong></p>
<ul>
<li>进程就是用来加载指令、管理内存、管理 IO 的</li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li>
</ul>
<p><strong>线程</strong></p>
<ul>
<li>一个进程之内可以分为一到多个线程。</li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li>
<li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li>
<li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li>
<li>进程间通信较为复杂
<ul>
<li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ul>
<p><strong>其他区别</strong></p>
<ul>
<li>1、因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。</li>
<li>2、体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。。</li>
<li>3、体现在CPU系统上面，线程使得CPU系统更加有效，因为操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</li>
<li>4、体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。</li>
</ul>
<h1 id="2synchronized原理"><a class="markdownIt-Anchor" href="#2synchronized原理"></a> 2.synchronized原理</h1>
<p><strong>java对象头</strong></p>
<p>普通对象</p>
<p><img src="/2023/02/17/juc/image-20230213132614988.png" alt="image-20230213132614988"></p>
<p>数组对象</p>
<p><img src="/2023/02/17/juc/image-20230213132639252.png" alt="image-20230213132639252"></p>
<p>64 位虚拟机 Mark Word</p>
<p><img src="/2023/02/17/juc/image-20230213132702541.png" alt="image-20230213132702541"></p>
<h2 id="monitor"><a class="markdownIt-Anchor" href="#monitor"></a> Monitor</h2>
<p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong></p>
<p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针</p>
<p>Monitor 结构如下</p>
<p><img src="/2023/02/17/juc/image-20230213133120665.png" alt="image-20230213133120665"></p>
<ul>
<li>刚开始 Monitor 中 Owner 为 null</li>
<li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一 个 Owner</li>
<li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList BLOCKED</li>
<li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</li>
<li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析</li>
</ul>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>synchronized 必须是进入同一个对象的 monitor 才有上述的效果</li>
<li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li>
</ul>
</blockquote>
<h2 id="轻量级锁"><a class="markdownIt-Anchor" href="#轻量级锁"></a> 轻量级锁</h2>
<p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以 使用轻量级锁来优化。</p>
<p>轻量级锁对使用者是透明的，即语法仍然是 synchronized</p>
<p>假设有两个方法同步块，利用同一个对象加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line"> <span class="comment">// 同步块 A</span></span><br><span class="line"> method2();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line"> <span class="comment">// 同步块 B</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</li>
</ul>
<p><img src="/2023/02/17/juc/image-20230213135229761.png" alt="image-20230213135229761"></p>
<ul>
<li>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存 入锁记录</li>
</ul>
<p><img src="/2023/02/17/juc/image-20230213135248243.png" alt="image-20230213135248243"></p>
<ul>
<li>
<p>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</p>
<p><img src="/2023/02/17/juc/image-20230213135309641.png" alt="image-20230213135309641"></p>
</li>
<li>
<p>如果 cas 失败，有两种情况</p>
<ul>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li>
<li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li>
</ul>
</li>
</ul>
<p><img src="/2023/02/17/juc/image-20230213135350177.png" alt="image-20230213135350177"></p>
<ul>
<li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重 入计数减一</li>
</ul>
<p><img src="/2023/02/17/juc/image-20230213135421083.png" alt="image-20230213135421083"></p>
<ul>
<li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头
<ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<h2 id="锁膨胀"><a class="markdownIt-Anchor" href="#锁膨胀"></a> 锁膨胀</h2>
<p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有 竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<ul>
<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>
</ul>
<p><img src="/2023/02/17/juc/image-20230213140303379.png" alt="image-20230213140303379"></p>
<ul>
<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程
<ul>
<li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</li>
<li>然后自己进入 Monitor 的 EntryList BLOCKED</li>
</ul>
</li>
</ul>
<p><img src="/2023/02/17/juc/image-20230213140331233.png" alt="image-20230213140331233"></p>
<ul>
<li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁 流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li>
</ul>
<h2 id="自旋优化"><a class="markdownIt-Anchor" href="#自旋优化"></a> 自旋优化</h2>
<p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步 块，释放了锁），这时当前线程就可以避免阻塞。</p>
<p>自旋重试成功的情况</p>
<p><img src="/2023/02/17/juc/image-20230213140510345.png" alt="image-20230213140510345"></p>
<p>自旋重试失败的情况</p>
<p><img src="/2023/02/17/juc/image-20230213140526827.png" alt="image-20230213140526827"></p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li>
<li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会 高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<h2 id="偏向锁"><a class="markdownIt-Anchor" href="#偏向锁"></a> 偏向锁</h2>
<p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p>
<p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p>
<p><strong>偏向状态</strong></p>
<p>对象头格式</p>
<p><img src="/2023/02/17/juc/image-20230213141342962.png" alt="image-20230213141342962"></p>
<p>一个对象创建时：</p>
<ul>
<li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0</li>
<li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 - XX:BiasedLockingStartupDelay=0 来禁用延迟</li>
<li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 age 都为 0，第一次用到 hashcode 时才会赋值</li>
</ul>
<h1 id="3wait-notify原理"><a class="markdownIt-Anchor" href="#3wait-notify原理"></a> 3.wait、notify原理</h1>
<p><img src="/2023/02/17/juc/image-20230213142224159.png" alt="image-20230213142224159"></p>
<ul>
<li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li>
<li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li>
<li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li>
<li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争</li>
</ul>
<h1 id="4park-unpark-原理"><a class="markdownIt-Anchor" href="#4park-unpark-原理"></a> 4.park unpark 原理</h1>
<p>每个线程都有自己的一个 Parker 对象，由三部分组成 _counter ， _cond 和 _mutex 打个比喻 _</p>
<ul>
<li>线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中 的备用干粮（0 为耗尽，1 为充足）</li>
<li>调用 park 就是要看需不需要停下来歇息
<ul>
<li>如果备用干粮耗尽，那么钻进帐篷歇息</li>
<li>如果备用干粮充足，那么不需停留，继续前进</li>
</ul>
</li>
<li>调用 unpark，就好比令干粮充足
<ul>
<li>如果这时线程还在帐篷，就唤醒让他继续前进</li>
<li>如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进
<ul>
<li>因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="5reentrantlock"><a class="markdownIt-Anchor" href="#5reentrantlock"></a> 5.ReentrantLock</h1>
<p>相对于 synchronized 它具备如下特点</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁</li>
<li>支持多个条件变量</li>
<li>与 synchronized 一样，都支持可重入</li>
</ul>
<p>基本用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> <span class="comment">// 释放锁</span></span><br><span class="line"> reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件变量"><a class="markdownIt-Anchor" href="#条件变量"></a> 条件变量</h2>
<p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待</p>
<p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</p>
<ul>
<li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li>
<li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li>
</ul>
<p>使用要点：</p>
<ul>
<li>await 前需要获得锁</li>
<li>await 执行后，会释放锁，进入 conditionObject 等待</li>
<li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li>
<li>竞争 lock 锁成功后，从 await 后继续执行</li>
</ul>
<h2 id="非公平锁实现原理"><a class="markdownIt-Anchor" href="#非公平锁实现原理"></a> 非公平锁实现原理</h2>
<p>先从构造器开始看，默认为非公平锁实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line"> sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NonfairSync 继承自 AQS</p>
<p>没有竞争时</p>
<p><img src="/2023/02/17/juc/image-20230213144544684.png" alt="image-20230213144544684"></p>
<p>第一个竞争出现时</p>
<p><img src="/2023/02/17/juc/image-20230213144600483.png" alt="image-20230213144600483"></p>
<p>Thread-1 执行了</p>
<ol>
<li>CAS 尝试将 state 由 0 改为 1，结果失败</li>
<li>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</li>
<li>接下来进入 addWaiter 逻辑，构造 Node 队列</li>
</ol>
<ul>
<li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态</li>
<li>Node 的创建是懒惰的</li>
<li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li>
</ul>
<p><img src="/2023/02/17/juc/image-20230213145417995.png" alt="image-20230213145417995"></p>
<p>当前线程进入 acquireQueued 逻辑</p>
<ol>
<li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li>
<li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li>
<li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false</li>
</ol>
<p><img src="/2023/02/17/juc/image-20230213145501204.png" alt="image-20230213145501204"></p>
<ol start="4">
<li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li>
<li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</li>
<li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li>
</ol>
<p><img src="/2023/02/17/juc/image-20230213145543910.png" alt="image-20230213145543910"></p>
<p>再次有多个线程经历上述过程竞争失败，变成这个样子</p>
<p><img src="/2023/02/17/juc/image-20230213145558046.png" alt="image-20230213145558046"></p>
<p>Thread-0 释放锁，进入 tryRelease 流程，如果成功</p>
<ul>
<li>设置 exclusiveOwnerThread 为 null</li>
<li>state = 0</li>
</ul>
<p><img src="/2023/02/17/juc/image-20230213145626572.png" alt="image-20230213145626572"></p>
<p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程</p>
<p>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1</p>
<p>回到 Thread-1 的 acquireQueued 流程</p>
<p><img src="/2023/02/17/juc/image-20230213150843395.png" alt="image-20230213150843395"></p>
<p>如果加锁成功（没有竞争），会设置</p>
<ul>
<li>exclusiveOwnerThread 为 Thread-1，state = 1</li>
<li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li>
<li>原本的 head 因为从链表断开，而可被垃圾回收</li>
</ul>
<p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</p>
<p><img src="/2023/02/17/juc/image-20230213150941238.png" alt="image-20230213150941238"></p>
<p>如果不巧又被 Thread-4 占了先</p>
<ul>
<li>Thread-4 被设置为 exclusiveOwnerThread，state = 1</li>
<li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li>
</ul>
<h2 id="可重入原理"><a class="markdownIt-Anchor" href="#可重入原理"></a> 可重入原理</h2>
<p><img src="/2023/02/17/juc/image-20230213151537230.png" alt="image-20230213151537230"></p>
<p><img src="/2023/02/17/juc/image-20230213151548031.png" alt="image-20230213151548031"></p>
<p><img src="/2023/02/17/juc/image-20230213151556253.png" alt="image-20230213151556253"></p>
<h2 id="条件变量实现原理"><a class="markdownIt-Anchor" href="#条件变量实现原理"></a> 条件变量实现原理</h2>
<p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p>
<p><strong>await 流程</strong></p>
<p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程</p>
<p>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p>
<p><img src="/2023/02/17/juc/image-20230213152200757.png" alt="image-20230213152200757"></p>
<p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p>
<p><img src="/2023/02/17/juc/image-20230213152226734.png" alt="image-20230213152226734"></p>
<p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p>
<p><img src="/2023/02/17/juc/image-20230213152248771.png" alt="image-20230213152248771"></p>
<p>park 阻塞 Thread-0</p>
<p><img src="/2023/02/17/juc/image-20230213152300864.png" alt="image-20230213152300864"></p>
<p><strong>signal 流程</strong></p>
<p>假设 Thread-1 要来唤醒 Thread-0</p>
<p><img src="/2023/02/17/juc/image-20230213152322187.png" alt="image-20230213152322187"></p>
<p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p>
<p><img src="/2023/02/17/juc/image-20230213152340898.png" alt="image-20230213152340898"></p>
<p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的 waitStatus 改为 -1</p>
<p><img src="/2023/02/17/juc/image-20230213152358996.png" alt="image-20230213152358996"></p>
<p>Thread-1 释放锁，进入 unlock 流程，略</p>
<h1 id="6volatile原理"><a class="markdownIt-Anchor" href="#6volatile原理"></a> 6.volatile原理</h1>
<p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p>
<ul>
<li>对 volatile 变量的写指令后会加入写屏障</li>
<li>对 volatile 变量的读指令前会加入读屏障</li>
</ul>
<h2 id="保证可见性"><a class="markdownIt-Anchor" href="#保证可见性"></a> 保证可见性</h2>
<ul>
<li>
<p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p>
</li>
<li>
<pre class="highlight"><code class="java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;
 	num = <span class="number">2</span>;
 	ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span>
	<span class="comment">// 写屏障</span>
&#125;
&lt;!--code￼<span class="number">3</span>--&gt;



</code></pre>
</li>
</ul>
<h2 id="保证有序性"><a class="markdownIt-Anchor" href="#保证有序性"></a> 保证有序性</h2>
<ul>
<li>
<p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p>
</li>
<li>
<pre class="highlight"><code class="java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;
 	num = <span class="number">2</span>;
 	ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span>
 	<span class="comment">// 写屏障</span>
&#125;
&lt;!--code￼<span class="number">4</span>--&gt;



</code></pre>
</li>
</ul>
<p>还是那句话，不能解决指令交错(字节码层面)：</p>
<ul>
<li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去</li>
<li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li>
</ul>
<h1 id="7线程池"><a class="markdownIt-Anchor" href="#7线程池"></a> 7.线程池</h1>
<p><strong>线程池（thread pool</strong>）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，对线程统一管理。</p>
<p>线程池就是存放线程的池子，池子里存放了很多可以复用的线程。</p>
<p>创建线程和销毁线程的花销是比较大的（手动new Thread 类），创建和消耗线程的时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程是比较消耗资源的。（我们可以把创建和销毁的线程的过程去掉）。</p>
<h2 id="线程池状态"><a class="markdownIt-Anchor" href="#线程池状态"></a> 线程池状态</h2>
<p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p>
<p><img src="/2023/02/17/juc/image-20230213161108770.png" alt="image-20230213161108770"></p>
<p>从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</p>
<p>这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作 进行赋值</p>
<ul>
<li><strong>running</strong>：初始化后的状态，表示线程池可以处理任务。</li>
<li><strong>shutdown</strong>：调用线程池的shutdown方法会使线程进入shutdown状态，从而调用execute的时候会抛出异常。但如果阻塞队列中还有任务，则会先将阻塞队列中的认为执行完，才会后收所有线程。</li>
<li><strong>stop</strong>：调用线程池的shutdownnow方法会使线程进入stop状态，既不能接受新的任务，也不能把阻塞队列中的任务执行完。</li>
<li><strong>tidying</strong>：在执行玩shutdownnow方法的时候，关闭完所有线程的时候，就会调用tryTerminate（）方法</li>
<li><strong>terminated</strong>：线程池处于TIDYING状态后，会执行terminated（）方法，执行完后就i进入terminated状态，在ThreadPoolExecutor中的terminated（）是一个空方法，可以自定义线程池重写这个方法，实现自定义的业务逻辑。</li>
</ul>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程池生命周期"></p>
<h2 id="工作流程"><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程</h2>
<ul>
<li>
<p>提交任务</p>
</li>
<li>
<p>当工作线程数小于核心线程数时，直接创建新的核心工作线程</p>
</li>
<li>
<p>当工作线程数不小于核心线程数时，就需要尝试将任务添加到阻塞队列中去</p>
</li>
<li>
<p>如果能够加入成功，说明队列还没有满，那么需要做以下的二次验证来保证添加进去的任务能够成功被执行</p>
</li>
<li>
<p>验证当前线程池的运行状态，如果是非RUNNING状态，则需要将任务从阻塞队列中移除，然后拒绝该任务</p>
</li>
<li>
<p>验证当前线程池中的工作线程的个数，如果为0，则需要主动添加一个空工作线程来执行刚刚添加到阻塞队列中的任务</p>
</li>
<li>
<p>如果加入失败，则说明队列已经满了，那么这时就需要创建新的“临时”工作线程来执行任务</p>
</li>
<li>
<p>如果创建成功，则直接执行该任务</p>
</li>
<li>
<p>如果创建失败，则说明工作线程数已经等于最大线程数了，则只能拒绝该任务了</p>
</li>
</ul>
<h2 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params"> 						  <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params"> 						  <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params"> 						  TimeUnit unit,</span></span><br><span class="line"><span class="params"> 						  BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params"> 					      ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">					      RejectedExecutionHandler handler)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>corePoolSize 核心线程数目 (最多保留的线程数)</p>
<ul>
<li><strong>CPU密集型：corePoolSize = CPU核数 + 1</strong></li>
<li><strong>IO密集型：corePoolSize = CPU核数 * 2</strong></li>
</ul>
</li>
<li>
<p>maximumPoolSize 最大线程数目</p>
</li>
<li>
<p>keepAliveTime 生存时间 - 针对救急线程</p>
</li>
<li>
<p>unit 时间单位 - 针对救急线程</p>
</li>
<li>
<p>workQueue 阻塞队列</p>
</li>
<li>
<p>threadFactory 线程工厂 - 可以为线程创建时起个好名字</p>
</li>
<li>
<p>handler 拒绝策略（可通过实现<code>RejectedExecutionHandler</code> 接口自定义拒绝策略）</p>
</li>
</ul>
<h2 id="工作队列"><a class="markdownIt-Anchor" href="#工作队列"></a> 工作队列</h2>
<p><strong>1、无界队列</strong></p>
<p>队列大小无限制，常用的为无界的<code>LinkedBlockingQueue</code>，使用该队列作为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致OOM。阅读代码发现，<code>Executors.newFixedThreadPool</code> 采用就是 <code>LinkedBlockingQueue</code>，而博主踩到的就是这个坑，当QPS很高，发送数据很大，大量的任务被添加到这个无界<code>LinkedBlockingQueue</code> 中，导致cpu和内存飙升服务器挂掉。</p>
<p>当然这种队列，<code>maximumPoolSize</code> 的值也就无效了。当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p>
<p><strong>2、有界队列</strong></p>
<p>当使用有限的 <code>maximumPoolSizes</code> 时，有界队列有助于防止资源耗尽，但是可能较难调整和控制。常用的有两类，一类是遵循FIFO原则的队列如<code>ArrayBlockingQueue</code>，另一类是优先级队列如<code>PriorityBlockingQueue</code>。<code>PriorityBlockingQueue</code>中的优先级由任务的Comparator决定。</p>
<p>使用有界队列时队列大小需和线程池大小互相配合，线程池较小有界队列较大时可减少内存消耗，降低cpu使用率和上下文切换，但是可能会限制系统吞吐量。</p>
<p><strong>3、同步移交队列</strong></p>
<p>如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用<code>SynchronousQueue</code>作为等待队列。<code>SynchronousQueue</code>不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入<code>SynchronousQueue</code>中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。</p>
<h2 id="newfixedthreadpool"><a class="markdownIt-Anchor" href="#newfixedthreadpool"></a> newFixedThreadPool</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line"> 								  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line"> 							      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特点</p>
<ul>
<li>核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li>阻塞队列是无界的，可以放任意数量的任务</li>
</ul>
<blockquote>
<p><strong>评价</strong> 适用于任务量已知，相对耗时的任务</p>
</blockquote>
<h2 id="newcachedthreadpool"><a class="markdownIt-Anchor" href="#newcachedthreadpool"></a> newCachedThreadPool</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line"> 								  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line"> 								  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特点</strong></p>
<ul>
<li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着
<ul>
<li>全部都是救急线程（60s 后可以回收）</li>
<li>救急线程可以无限创建</li>
</ul>
</li>
<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交 货）</li>
</ul>
<blockquote>
<p><strong>评价</strong> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线 程。 适合任务数比较密集，但每个任务执行时间较短的情况</p>
</blockquote>
<h2 id="newsinglethreadexecutor"><a class="markdownIt-Anchor" href="#newsinglethreadexecutor"></a> newSingleThreadExecutor</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line"> 		(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line"> 								<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line"> 								<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong>： 希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程 也不会被释放。</p>
<p><strong>区别</strong>：</p>
<ul>
<li>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一 个线程，保证池的正常工作</li>
<li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改
<ul>
<li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因 此不能调用 ThreadPoolExecutor 中特有的方法</li>
</ul>
</li>
<li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改
<ul>
<li>对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li>
</ul>
</li>
</ul>
<h2 id="任务提交"><a class="markdownIt-Anchor" href="#任务提交"></a> 任务提交</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> </span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params"> 							  <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"> 				<span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line"> 	<span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params"> 					<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"> 			<span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="关闭线程池"><a class="markdownIt-Anchor" href="#关闭线程池"></a> 关闭线程池</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 SHUTDOWN</span></span><br><span class="line"><span class="comment"> - 不会接收新任务</span></span><br><span class="line"><span class="comment"> - 但已提交任务会执行完</span></span><br><span class="line"><span class="comment"> - 此方法不会阻塞调用线程的执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 STOP</span></span><br><span class="line"><span class="comment"> - 不会接收新任务</span></span><br><span class="line"><span class="comment"> - 会将队列中的任务返回</span></span><br><span class="line"><span class="comment"> - 并用 interrupt 的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池状态是否是 TERMINATED</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待   </span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<h2 id="任务调度线程池"><a class="markdownIt-Anchor" href="#任务调度线程池"></a> 任务调度线程池</h2>
<p>使用 ScheduledExecutorService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line"> 	System.out.println(<span class="string">&quot;任务1，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"> 	<span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line"> 	System.out.println(<span class="string">&quot;任务2，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>
<p>scheduleAtFixedRate 循环执行例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line"> 	log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="/2023/02/17/juc/image-20230213163448999.png" alt="image-20230213163448999"></p>
<p>scheduleAtFixedRate 例子（任务执行时间超过了间隔时间）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line"> 	log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line"> 	sleep(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>输出分析：一开始，延时 1s，接下来，由于任务执行时间 &gt; 间隔时间，间隔被『撑』到了 2s</p>
<p><img src="/2023/02/17/juc/image-20230213163530988.png" alt="image-20230213163530988"></p>
<p>scheduleWithFixedDelay 例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">pool.scheduleWithFixedDelay(()-&gt; &#123;</span><br><span class="line"> 	log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line"> 	sleep(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束 &lt;-&gt; 延时 &lt;-&gt; 下一个任务开始 所 以间隔都是 3s</p>
<p><img src="/2023/02/17/juc/image-20230213163840871.png" alt="image-20230213163840871"></p>
<blockquote>
<p><strong>评价</strong> 整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线 程也不会被释放。用来执行延迟或反复执行的任务</p>
</blockquote>
<h2 id="forkjoin"><a class="markdownIt-Anchor" href="#forkjoin"></a> Fork/Join</h2>
<p>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型</p>
<p>运算 所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解</p>
<p>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率</p>
<p>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池</p>
<p><strong>使用</strong>：</p>
<p>提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下 面定义了一个对 1~n 之间的整数求和的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.AddTask&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddTask1</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"> 	<span class="type">int</span> n;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="title function_">AddTask1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"> 		<span class="built_in">this</span>.n = n;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + n + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"> 	<span class="comment">// 如果 n 已经为 1，可以求得结果了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"> 			log.debug(<span class="string">&quot;join() &#123;&#125;&quot;</span>, n);</span><br><span class="line"> 			<span class="keyword">return</span> n;</span><br><span class="line"> 		&#125;</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">// 将任务进行拆分(fork)</span></span><br><span class="line"> 		<span class="type">AddTask1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask1</span>(n - <span class="number">1</span>);</span><br><span class="line"> 		t1.fork();</span><br><span class="line"> 		log.debug(<span class="string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">// 合并(join)结果</span></span><br><span class="line"> 		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> n + t1.join();</span><br><span class="line"> 		log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);</span><br><span class="line"> 		<span class="keyword">return</span> result;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后提交给 ForkJoinPool 来执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> 	<span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line"> 	System.out.println(pool.invoke(<span class="keyword">new</span> <span class="title class_">AddTask1</span>(<span class="number">5</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2023/02/17/juc/image-20230213165241399.png" alt="image-20230213165241399"></p>
<h1 id="8aqs"><a class="markdownIt-Anchor" href="#8aqs"></a> 8.AQS</h1>
<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p>
<p>AQS定义了一套多线程访问共享资源的同步模板，解决了实现同步器时涉及的大量细节问题，能够极大地减少实现工作</p>
<p>AQS的组成结构</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/AQS%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png" alt="img"></p>
<p>三部分组成：<code>volatile int state同步状态</code>、<code>Node组成的CLH队列</code>、<code>ConditionObject条件变量</code>（包含Node组成的条件单向队列）。</p>
<p>特点：</p>
<ul>
<li>
<p>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</p>
<ul>
<li>getState - 获取 state 状态</li>
<li>setState - 设置 state 状态</li>
<li>compareAndSetState - cas 机制设置 state 状态</li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
<li>ReentrantLock的state用来表示是否有锁资源</li>
<li>ReentrantReadWriteLock的state高16位代表读锁状态，低16位代表写锁状态</li>
<li>Semaphore的state用来表示可用信号的个数</li>
<li>CountDownLatch的state用来表示计数器的值</li>
</ul>
</li>
<li>
<p>提供了基于 FIFO （先进先出）的等待队列，类似于 Monitor 的 EntryList</p>
</li>
<li>
<p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</p>
</li>
</ul>
<p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p>
<ul>
<li>tryAcquire</li>
<li>tryRelease</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively</li>
</ul>
<p>获取锁的姿势：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line"> 	<span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放锁的姿势</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"> 	<span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h2>
<p><strong>实现不可重入锁</strong></p>
<p><strong>自定义同步器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MySync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line"> 		<span class="keyword">if</span> (acquires == <span class="number">1</span>)&#123;</span><br><span class="line"> 			<span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"> 				setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"> 				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line"> 		<span class="keyword">if</span>(acquires == <span class="number">1</span>) &#123;</span><br><span class="line"> 			<span class="keyword">if</span>(getState() == <span class="number">0</span>) &#123;</span><br><span class="line"> 				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line"> 			&#125;</span><br><span class="line"> 			setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line"> 			setState(<span class="number">0</span>);</span><br><span class="line"> 			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">protected</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line"> 		<span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自定义锁</strong></p>
<p>有了自定义同步器，很容易复用 AQS ，实现一个功能完备的自定义锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">static</span> <span class="type">MySync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="comment">// 尝试，不成功，进入等待队列</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line"> 		sync.acquire(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="comment">// 尝试，不成功，进入等待队列，可打断</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"> 		sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="comment">// 尝试一次，不成功返回，不进入队列</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line"> 		<span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="comment">// 尝试，不成功，进入等待队列，有时限</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"> 		<span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="comment">// 释放锁</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line"> 		sync.release(<span class="number">1</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="comment">// 生成条件变量</span></span><br><span class="line"> 	<span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line"> 		<span class="keyword">return</span> sync.newCondition();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="clh队列"><a class="markdownIt-Anchor" href="#clh队列"></a> CLH队列</h2>
<p>CLH是AQS内部维护的FIFO（先进先出）双端双向队列（方便尾部节点插入），基于链表数据结构，当一个线程竞争资源失败，就会将等待资源的线程封装成一个Node节点，通过CAS原子操作插入队列尾部，最终不同的Node节点连接组成了一个CLH队列，所以说AQS通过CLH队列管理竞争资源的线程，个人总结CLH队列具有如下几个优点：</p>
<ul>
<li>先进先出保证了公平性</li>
<li>非阻塞的队列，通过自旋锁和CAS保证节点插入和移除的原子性，实现无锁快速插入</li>
<li>采用了自旋锁思想，所以CLH也是一种基于链表的可扩展、高性能、公平的自旋锁</li>
</ul>
<h2 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h2>
<p>线程获取资源失败，封装成<code>Node</code>节点从<code>CLH</code>队列尾部入队并阻塞线程，某线程释放资源时会把<code>CLH</code>队列首部<code>Node</code>节点关联的线程唤醒（<strong>此处的首部是指第二个节点，后面会细说</strong>），再次获取资源。，</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/AQS-%E6%B5%81%E7%A8%8B.png" alt="AQS-流程"></p>
<p><strong>入队</strong></p>
<p>获取资源失败的线程需要封装成<code>Node</code>节点，接着尾部入队，在<code>AQS</code>中提供<code>addWaiter</code>函数完成<code>Node</code>节点的创建与入队。</p>
<p>添加节点的时候，如果从<code>CLH</code>队列已经存在，通过<code>CAS</code>快速将当前节点添加到队列尾部，如果添加失败或队列不存在，则指向<code>enq</code>函数自旋入队。</p>
<p>通过自旋<code>CAS</code>尝试往队列尾部插入节点，直到成功，自旋过程如果发现<code>CLH</code>队列不存在时会初始化<code>CLH</code>队列，入队过程流程如下图：</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/AQS-%E5%85%A5%E9%98%9F%E8%BF%87%E7%A8%8B%E6%B5%81%E7%A8%8B.png" alt="AQS-入队过程流程"></p>
<p>第一次循环</p>
<ul>
<li>刚开始C L H队列不存在，head与tail都指向null</li>
<li>要初始化C L H队列，会创建一个哨兵节点，head与tail都指向哨兵节点</li>
</ul>
<p>第二次循环</p>
<ul>
<li>当前线程节点的前驱节点指向尾部节点（哨兵节点）</li>
<li>设置当前线程节点为尾部，tail指向当前线程节点</li>
<li>前尾部节点的后驱节点指向当前线程节点（当前尾部节点）</li>
</ul>
<p>最后结合addWaiter与enq函数的入队流程图如下</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/AQS-%E5%85%A5%E9%98%9F%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="AQS-入队流程图"></p>
<p><strong>出队</strong></p>
<p><code>CLH</code>队列中的节点都是获取资源失败的线程节点，当持有资源的线程释放资源时，会将<code>head.next</code>指向的线程节点唤醒（<strong><code>CLH</code>队列的第二个节点</strong>），如果唤醒的线程节点获取资源成功，线程节点清空信息设置为头部节点（<strong>新哨兵节点</strong>），原头部节点出队（<strong>原哨兵节点</strong>）<strong>acquireQueued函数中的部分代码</strong></p>
<p>假设获取资源成功，更换头部节点，并把头部节点的信息清除变成哨兵节点，注意这个过程是不需要使用<code>CAS</code>来保证，因为只有一个线程能够成功获取到资源。</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/AQS-%E5%87%BA%E9%98%9F%E6%B5%81%E7%A8%8B.png" alt="AQS-出队流程"></p>
<p><strong>条件变量</strong></p>
<p>Object的wait、notify函数是配合Synchronized锁实现线程间同步协作的功能，A Q S的ConditionObject条件变量也提供这样的功能，通过ConditionObject的await和signal两类函数完成。不同于Synchronized锁，一个A Q S可以对应多个条件变量，而Synchronized只有一个</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/AQS-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F.png" alt="AQS-条件变量"></p>
<p>如上图所示，ConditionObject内部维护着一个单向条件队列，不同于C H L队列，条件队列只入队执行await的线程节点，并且加入条件队列的节点，不能在C H L队列， 条件队列出队的节点，会入队到C H L队列。</p>
<p>当某个线程执行了ConditionObject的await函数，阻塞当前线程，线程会被封装成Node节点添加到条件队列的末端，其他线程执行ConditionObject的signal函数，会将条件队列头部线程节点转移到C H L队列参与竞争资源，具体流程如下图</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/AQS-CHL%E9%98%9F%E5%88%97%E5%8F%82%E4%B8%8E%E6%B5%81%E7%A8%8B.png" alt="AQS-CHL队列参与流程"></p>
<h2 id="共享方式"><a class="markdownIt-Anchor" href="#共享方式"></a> 共享方式</h2>
<p>AQS定义两种资源共享方式。无论是独占锁还是共享锁，本质上都是对AQS内部的一个变量<code>state</code>的获取。<code>state</code>是一个原子的int变量，用来表示锁状态、资源数等。</p>
<p><strong>① 独占锁(<code>Exclusive</code>)模式</strong>：只能被一个线程获取到(<code>Reentrantlock</code>)。</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/%E7%8B%AC%E5%8D%A0%E9%94%81(Exclusive)%E6%A8%A1%E5%BC%8F.png" alt="独占锁(Exclusive)模式"></p>
<p><strong>② 共享锁(<code>Share</code>)模式</strong>：可以被多个线程同时获取(<code>Semaphore/CountDownLatch/ReadWriteLock</code>)。</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JAVA/%E5%85%B1%E4%BA%AB%E9%94%81(Share)%E6%A8%A1%E5%BC%8F.png" alt="共享锁(Share)模式"></p>
<h2 id="state机制"><a class="markdownIt-Anchor" href="#state机制"></a> state机制</h2>
<p>提供<code>volatile</code>变量<code>state</code>，用于同步线程之间的共享状态。通过 <code>CAS</code> 和 <code>volatile</code> 保证其原子性和可见性。核心要点：</p>
<ul>
<li>state 用 <code>volatile</code> 修饰，保证多线程中的可见性</li>
<li><code>getState()</code> 和 <code>setState()</code> 方法<strong>采用final修饰</strong>，限制AQS的子类重写它们两</li>
<li><code>compareAndSetState()</code> 方法采用乐观锁思想的CAS算法，也是采用final修饰的，不允许子类重写</li>
</ul>
<p><strong>state应用案例</strong>：</p>
<table>
<thead>
<tr>
<th>案例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Semaphore</code></td>
<td>使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数</td>
</tr>
<tr>
<td><code>CountDownLatch</code></td>
<td>使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过</td>
</tr>
<tr>
<td><code>ReentrantReadWriteLock</code></td>
<td>使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数</td>
</tr>
<tr>
<td><code>ThreadPoolExecutor</code></td>
<td>Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）</td>
</tr>
<tr>
<td><code>ReentrantLock</code></td>
<td>使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理</td>
</tr>
</tbody>
</table>
<h1 id="9semaphore"><a class="markdownIt-Anchor" href="#9semaphore"></a> 9.Semaphore</h1>
<p>用来限制能同时访问共享资源的线程上限。</p>
<p>Semaphore是一个计数信号量，它的本质是一个&quot;共享锁&quot;。信号量维护了一个信号量许可集。线程可以通过调用acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。</p>
<h2 id="流程-2"><a class="markdownIt-Anchor" href="#流程-2"></a> 流程</h2>
<p>Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后 停车场显示空余车位减一</p>
<p>刚开始，permits（state）为 3，这时 5 个线程来获取资源</p>
<p><img src="/2023/02/17/juc/image-20230213212816669.png" alt="image-20230213212816669"></p>
<p>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列 park 阻塞</p>
<p><img src="/2023/02/17/juc/image-20230213212834190.png" alt="image-20230213212834190"></p>
<p>这时 Thread-4 释放了 permits，状态如下</p>
<p><img src="/2023/02/17/juc/image-20230213212927453.png" alt="image-20230213212927453"></p>
<p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接 下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p>
<p><img src="/2023/02/17/juc/image-20230213212945122.png" alt="image-20230213212945122"></p>
<h1 id="10-countdownlatch"><a class="markdownIt-Anchor" href="#10-countdownlatch"></a> 10. CountDownLatch</h1>
<p>用来进行线程同步协作，<strong>等待所有线程完成倒计时</strong>。 其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p>
<p>CountDownLatch是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</p>
<p><strong>CountDownLatch和CyclicBarrier的区别</strong></p>
<ul>
<li>CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待</li>
<li>CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier</li>
</ul>
<h1 id="11cyclicbarrier"><a class="markdownIt-Anchor" href="#11cyclicbarrier"></a> 11.CyclicBarrier</h1>
<p>循环栅栏，用来进行线程协作，等待线程<strong>满足某个计数</strong>。构造时设置『计数个数』，每个线程执 行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p>
<p>CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。</p>
<h1 id="12多线程通信"><a class="markdownIt-Anchor" href="#12多线程通信"></a> 12.多线程通信</h1>
<h2 id="通信"><a class="markdownIt-Anchor" href="#通信"></a> 通信</h2>
<p>多线程通讯的方式主要包括以下几种：</p>
<ul>
<li><strong>使用volatile关键词：基于共享内存的思想</strong></li>
<li><strong>使用Synchronized+Object类的wait()/notify()/notifyAll()方法</strong></li>
<li><strong>使用JUC工具类CountDownLatch：基于共享变量state实现</strong></li>
<li><strong>使用Lock（ReentrantLock）结合Condition</strong></li>
<li><strong>基于LockSupport实现线程间的阻塞和唤醒</strong></li>
</ul>
<h2 id="线程协作"><a class="markdownIt-Anchor" href="#线程协作"></a> 线程协作</h2>
<h3 id="sleepyieldjoin"><a class="markdownIt-Anchor" href="#sleepyieldjoin"></a> sleep/yield/join</h3>
<p><strong>sleep()</strong></p>
<ul>
<li>让当前线程暂停指定的时间（毫秒）</li>
<li>wait方法依赖于同步，而sleep方法可以直接调用</li>
<li>sleep方法只是暂时让出CPU的执行权，并不释放锁，而wait方法则需要释放锁</li>
</ul>
<p><strong>yield()</strong></p>
<ul>
<li>暂停当前线程，让出当前CPU的使用权，以便其它线程有机会执行</li>
<li>不能指定暂停的时间，并且也不能保证当前线程马上停止</li>
<li>会让当前线程从运行状态转变为就绪状态</li>
<li>yield只能使同优先级或更高优先级的线程有执行的机会</li>
</ul>
<p><strong>join()</strong></p>
<ul>
<li>等待调用 join 方法的线程执行结束，才执行后面的代码</li>
<li>其调用一定要在 start 方法之后（看源码可知）</li>
<li>作用是父线程等待子线程执行完成后再执行（即将异步执行的线程合并为同步的线程）</li>
</ul>
<h3 id="waitnotifynotifyall"><a class="markdownIt-Anchor" href="#waitnotifynotifyall"></a> wait/notify/notifyAll</h3>
<p>一般需要配合<strong>synchronized</strong>一起使用。<strong>Object</strong>的主要方法如下：</p>
<ul>
<li><strong>wait()</strong>：阻塞当前线程，直到 notify 或者 notifyAll 来唤醒</li>
<li><strong>notify()</strong>：只能唤醒一个处于 wait 的线程</li>
<li><strong>notifyAll()</strong>：唤醒全部处于 wait 的线程</li>
</ul>
<h3 id="awaitsignalsignalall"><a class="markdownIt-Anchor" href="#awaitsignalsignalall"></a> await/signal/signalAll</h3>
<p>使用显式的 <strong>Lock</strong> 和 <strong>Condition</strong> 对象：</p>
<ul>
<li><strong>await()</strong>：当前线程进入等待状态，直到被通知（signal/signalAll）、中断或超时</li>
<li><strong>signal()</strong>：唤醒一个等待在Condition上的线程，将该线程从<strong>等待队列</strong>中转移到<strong>同步队列</strong>中</li>
<li><strong>signalAll()</strong>：能够唤醒所有等待在Condition上的线程</li>
</ul>
<h1 id="13threadlocal"><a class="markdownIt-Anchor" href="#13threadlocal"></a> 13.ThreadLocal</h1>
<blockquote>
<p>在多线程访问共享资源时会采取一定的线程同步方式（如：加锁）来解决带来的并发问题。（如图）</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/cc4383cf5f5043d79feb662bf6b0ef13.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS2lkZHl1cA==,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="img"></p>
<p>使用ThreadLocal对共享资源的访问也可以解决并发问题</p>
<p>**作用：**ThreadLocal提供了线程的本地变量，即当创建一个变量后，每个线程对其进行访问的时候访问的是自己线程的变量。</p>
<p><img src="https://img-blog.csdnimg.cn/8f296c0d74594c369784d61fb440cb74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS2lkZHl1cA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="img"></p>
<blockquote>
<p>这里的本地内存并不是线程的工作内存，而是Thread类中的一个变量，而不是放在不是存放在ThreadLocal实例里面</p>
</blockquote>
<p><strong>这样做的好处：</strong></p>
<ul>
<li>线程安全，可以避免多线程访问同一个共享变量导致的并发问题。</li>
<li>不需要加锁，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</li>
</ul>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<p><strong>ThreadLocalMap</strong></p>
<p>前面提到：每个线程的本地变量是放在调用线程Thread类中的一个变量<code>threadLocals</code>中，而不是放在不是存放在<code>ThreadLocal</code>实例里面</p>
<p><code>ThreadLocal</code>是基于每个线程对象内部的一个叫做<code>threadLocals</code>的属性来实现的，它的类型是<code>ThreadLocalMap</code>（说白了就是一个Map对象）。它以<code>ThreadLocal</code>本本身作为键值（注意：这里的引用为<strong>弱引用</strong>），副本对象作为value存储，这样当每个线程调用该对象时就可以直接从自身的<code>threadLocals</code>属性中获取变量副本来进行操作。</p>
<p><strong>为什么要用map？</strong></p>
<ul>
<li>这是因为在实际使用中可能会有多个<code>ThreadLocal</code>变量，因此需要将这些<code>ThreadLocal</code>添加到map中。</li>
</ul>
<p><strong>为什么要设置为弱引用？</strong></p>
<ul>
<li>
<p>如果为强引用： 由于<code>ThreadLocalMap</code>是属于线程的，而我们创建多线程时一般是使用线程池进行创建，线程池中的部分线程在任务结束后是不会关闭的，那么这部分线程中的<code>ThreadLocalMap</code>将会一直持有对<code>ThreadLocal</code>对象的强引用，导致<code>ThreadLocal</code>对象无法被垃圾回收，从而造成内存泄漏。</p>
</li>
<li>
<p>因此设置为弱引用：在下一次垃圾回收时，无论内存空间是否足够，只有弱引用指向的对象都会被直接回收。所以将<code>ThreadLocalMap</code>对<code>ThreadLocal</code>对象的引用设置成弱引用，就能避免<code>ThreadLocal</code>对象无法回收导致内存泄漏的问题。</p>
</li>
</ul>
<p><strong>内存泄露解决</strong></p>
<p><strong>解决</strong>：在finally中remove即可。</p>
<h1 id="14线程间异步传参"><a class="markdownIt-Anchor" href="#14线程间异步传参"></a> 14.线程间异步传参</h1>
<p>使用阿里开源的<strong>TransmittableThreadLocal（TTL）</strong></p>
<p>详见官网：<a target="_blank" rel="noopener" href="https://gitcode.net/mirrors/alibaba/transmittable-thread-local?utm_source=csdn_github_accelerator">https://gitcode.net/mirrors/alibaba/transmittable-thread-local?utm_source=csdn_github_accelerator</a></p>
<h1 id="15进程间的通信方式"><a class="markdownIt-Anchor" href="#15进程间的通信方式"></a> 15.进程间的通信方式</h1>
<p><strong>管道</strong></p>
<p><strong>消息队列</strong></p>
<p><strong>共享内存</strong></p>
<ul>
<li>
<p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那共享内存的方式，就很好的解决了这一问题。</p>
</li>
<li>
<p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程A和 进程B的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p>
</li>
<li>
<p>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去， 大大提高了进程间通信的速度。</p>
</li>
</ul>
<p><strong>信号量</strong></p>
<ul>
<li>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</li>
<li><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong></li>
</ul>
<p><strong>信号</strong></p>
<ul>
<li>信号一般用于一些异常情况下的进程间通信，是一种异步通信，它的数据结构一般就是一个数字。</li>
</ul>
<p><strong>socket</strong></p>
<ul>
<li>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要Socket通信了</strong>。</li>
<li>实际上，Socket通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/5b31435597474878b570662cabf940b3.png" alt="img"></p>
<h1 id="16其他问题"><a class="markdownIt-Anchor" href="#16其他问题"></a> 16.其他问题</h1>
<p><strong>内核态和用户态的区别</strong></p>
<ul>
<li>
<p>内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。</p>
</li>
<li>
<p>用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。</p>
</li>
</ul>
<p>**string stringbuffer stringbuilder的区别，各自的使用场景 **</p>
<ul>
<li>
<p>1、String是一个final类，代表不可变的字符序列，也就是String引用的字符串是不能改变的</p>
</li>
<li>
<p>2、StringBuffer/StringBuilder表示的字符串对象可以直接进行修改，而且方法也一样</p>
</li>
<li>
<p>3、StringBuilder是java5中引入的，和StringBuffer的方法完全相同。区别在与它是单线程环境下使用的，因为他的所有方法都没有synchronized修饰，他的效率理论上比StringBuffer要高</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>字符序列类型</th>
<th>效率</th>
<th>线程是否安全</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>不可变字符序列</td>
<td>效率低，但是复用率高</td>
<td></td>
</tr>
<tr>
<td>StringBuffer</td>
<td>可变字符序列</td>
<td>效率较高（在增删情况下）</td>
<td>安全</td>
</tr>
<tr>
<td>StringBuilder</td>
<td>可变字符序列</td>
<td>效率最高</td>
<td>不安全</td>
</tr>
</tbody>
</table>
<p>​</p>
<p><strong>任务事件中 如何保障多线程情况下线程安全的进行上层的writeAndFlush？</strong></p>
<ul>
<li>synchronized方法</li>
<li>加锁机制（<strong>ReentrantLock</strong>等）</li>
<li>使用Atomic对象</li>
<li>使用无状态对象（同样的输入返回一致的结果）</li>
<li>使用不可变对象（final）</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://cloud-tour.github.io/2023/02/17/juc/" title="juc" target="_blank" rel="external">http://cloud-tour.github.io/2023/02/17/juc/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/Cloud-Tour" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar2.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/Cloud-Tour" target="_blank"><span class="text-dark">Cloud-Tour</span><small class="ml-1x">Development Engineer &amp; Java</small></a></h3>
        <div>A man who wants to float on the cloud</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2023/02/17/jvm/" title="jvm"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2023/02/17/javase/" title="javase"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button">    <span>[&nbsp;</span><span>Catalogue</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>$</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>Maybe you could buy me a cup of coffee.</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open alipay app scan this qrcode, buy me a coffee!</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open wechat app scan this qrcode, buy me a coffee!</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> alipay</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> wechat payment</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Cloud-Tour" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>