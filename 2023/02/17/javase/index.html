<!DOCTYPE html>
<html lang=en>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>javase | Hexo</title>
  <meta name="description" content="1.equals和hashcode的区别 在Java中任何一个对象都具备equals(Object obj)和hashCode()这两个方法，因为他们是在Object类中定义的。 equals(Object obj)方法用来判断两个对象是否“相同”，如果“相同”则返回true，否则返回false。 hashCode()方法返回一个int数，在Object类中的默认实现是“将该对象的内部地址转换成">
<meta property="og:type" content="article">
<meta property="og:title" content="javase">
<meta property="og:url" content="http://cloud-tour.github.io/2023/02/17/javase/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.equals和hashcode的区别 在Java中任何一个对象都具备equals(Object obj)和hashCode()这两个方法，因为他们是在Object类中定义的。 equals(Object obj)方法用来判断两个对象是否“相同”，如果“相同”则返回true，否则返回false。 hashCode()方法返回一个int数，在Object类中的默认实现是“将该对象的内部地址转换成">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406172947233.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173037693.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173048904.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173105983.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173112557.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173122348.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173143746.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173155292.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173205323.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173326661.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173356533.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173404344.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173416188.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173428455.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173437114.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173443142.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173449490.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173457167.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173505430.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173512991.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173519522.png">
<meta property="og:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406173526653.png">
<meta property="article:published_time" content="2023-02-17T12:58:55.387Z">
<meta property="article:modified_time" content="2023-04-06T09:35:30.403Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cloud-tour.github.io/2023/02/17/javase/image-20230406172947233.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://cloud-tour.github.io/2023/02/17/javase/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/Cloud-Tour" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar2.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Cloud-Tour</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Development Engineer &amp; Java</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> MaoMing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">Repository</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">Books</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">Links</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">About</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Cloud-Tour" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/">51单片机</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javase/">javase</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/juc/">juc</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm/">jvm</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AQS/" rel="tag">AQS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lock/" rel="tag">Lock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReentrantLock/" rel="tag">ReentrantLock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Synchronized/" rel="tag">Synchronized</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debian/" rel="tag">debian</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java11/" rel="tag">java11</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/" rel="tag">juc</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/" rel="tag">jvm</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keil/" rel="tag">keil</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/proteus/" rel="tag">proteus</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssb/" rel="tag">ssb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssm/" rel="tag">ssm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A0%86%E6%8A%A2%E5%8D%A0/" rel="tag">堆抢占</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8/" rel="tag">跨代引用</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AQS/" style="font-size: 13px;">AQS</a> <a href="/tags/Lock/" style="font-size: 13px;">Lock</a> <a href="/tags/ReentrantLock/" style="font-size: 13px;">ReentrantLock</a> <a href="/tags/Synchronized/" style="font-size: 13px;">Synchronized</a> <a href="/tags/debian/" style="font-size: 13.5px;">debian</a> <a href="/tags/java/" style="font-size: 14px;">java</a> <a href="/tags/java11/" style="font-size: 13px;">java11</a> <a href="/tags/juc/" style="font-size: 13.5px;">juc</a> <a href="/tags/jvm/" style="font-size: 13.5px;">jvm</a> <a href="/tags/kafka/" style="font-size: 13px;">kafka</a> <a href="/tags/keil/" style="font-size: 13px;">keil</a> <a href="/tags/mysql/" style="font-size: 13px;">mysql</a> <a href="/tags/nginx/" style="font-size: 13px;">nginx</a> <a href="/tags/proteus/" style="font-size: 13px;">proteus</a> <a href="/tags/redis/" style="font-size: 13px;">redis</a> <a href="/tags/ssb/" style="font-size: 13px;">ssb</a> <a href="/tags/ssm/" style="font-size: 13px;">ssm</a> <a href="/tags/%E5%A0%86%E6%8A%A2%E5%8D%A0/" style="font-size: 13px;">堆抢占</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 13px;">线程池</a> <a href="/tags/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8/" style="font-size: 13px;">跨代引用</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/jvm/">jvm</a>
              </p>
              <p class="item-title">
                <a href="/2023/04/05/new%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%A0%86%E6%8A%A2%E5%8D%A0%E9%97%AE%E9%A2%98/" class="title">new对象时的堆抢占问题</a>
              </p>
              <p class="item-date">
                <time datetime="2023-04-05T06:29:33.616Z" itemprop="datePublished">2023-04-05</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/jvm/">jvm</a>
              </p>
              <p class="item-title">
                <a href="/2023/04/05/JVM%E4%B8%AD%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/" class="title">JVM跨代引用问题的处理方式</a>
              </p>
              <p class="item-date">
                <time datetime="2023-04-05T06:14:22.940Z" itemprop="datePublished">2023-04-05</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/juc/">juc</a>
              </p>
              <p class="item-title">
                <a href="/2023/04/02/AQS%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/" class="title">AQS原理流程解析</a>
              </p>
              <p class="item-date">
                <time datetime="2023-04-02T14:30:07.396Z" itemprop="datePublished">2023-04-02</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/juc/">juc</a>
              </p>
              <p class="item-title">
                <a href="/2023/04/02/ReentrantLock%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90/" class="title">ReentrantLock底层实现解析</a>
              </p>
              <p class="item-date">
                <time datetime="2023-04-02T12:08:51.583Z" itemprop="datePublished">2023-04-02</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/juc/">juc</a>
              </p>
              <p class="item-title">
                <a href="/2023/04/02/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/" class="title">java线程池详解</a>
              </p>
              <p class="item-date">
                <time datetime="2023-04-02T11:55:50.087Z" itemprop="datePublished">2023-04-02</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1equals%E5%92%8Chashcode%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text"> 1.equals和hashcode的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text"> 2.树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">2.1.</span> <span class="toc-text"> 二叉搜索树（二叉查找树）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91alv"><span class="toc-number">2.2.</span> <span class="toc-text"> 二叉平衡树（ALV）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text"> 红黑树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-number">3.</span> <span class="toc-text"> 3.java异常体系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text"> 4.面向对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text"> 5.接口与抽象类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text"> 6.静态变量和普通变量的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E6%9C%89%E4%BA%86int%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81integer"><span class="toc-number">7.</span> <span class="toc-text"> 7.有了int为什么还要Integer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8java%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text"> 8.Java泛型的好处及底层原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9java%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.</span> <span class="toc-text"> 9.java定时器实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8timer%E5%92%8C%E5%92%8Ctimertask%E7%B1%BB"><span class="toc-number">9.1.</span> <span class="toc-text"> 使用Timer和和TimerTask类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">9.2.</span> <span class="toc-text"> 使用线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8spring-task"><span class="toc-number">9.3.</span> <span class="toc-text"> 使用Spring Task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87quartz%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B7%A5%E5%85%B7"><span class="toc-number">9.4.</span> <span class="toc-text"> 通过Quartz任务调度工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10java%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%98%9F%E5%88%97"><span class="toc-number">10.</span> <span class="toc-text"> 10.java中有哪些队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E8%8E%B7%E5%8F%96%E7%B1%BB%E4%B8%AD%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="toc-number">11.</span> <span class="toc-text"> 11.获取类中私有属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">12.</span> <span class="toc-text"> 12.分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">12.1.</span> <span class="toc-text"> 二阶段提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">12.2.</span> <span class="toc-text"> 三阶段提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ttc"><span class="toc-number">12.3.</span> <span class="toc-text"> TTC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#saga%E4%BA%8B%E5%8A%A1"><span class="toc-number">12.4.</span> <span class="toc-text"> Saga事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8"><span class="toc-number">12.5.</span> <span class="toc-text"> 本地消息表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5"><span class="toc-number">12.6.</span> <span class="toc-text"> 最大努力通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E6%96%B9%E6%A1%88%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">12.7.</span> <span class="toc-text"> 各方案常见使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13%E5%85%B6%E4%BB%96"><span class="toc-number">13.</span> <span class="toc-text"> 13.其他</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-javase" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      javase
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2023/02/17/javase/" class="article-date">
	  <time datetime="2023-02-17T12:58:55.387Z" itemprop="datePublished">2023-02-17</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/javase/">javase</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/java/" rel="tag">java</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2023/02/17/javase/#comments" class="article-comment-link">Comments</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="1equals和hashcode的区别"><a class="markdownIt-Anchor" href="#1equals和hashcode的区别"></a> 1.equals和hashcode的区别</h1>
<p>在Java中任何一个对象都具备equals(Object obj)和hashCode()这两个方法，因为他们是在Object类中定义的。</p>
<p><strong>equals</strong>(Object obj)方法用来判断两个对象是否“相同”，如果“相同”则返回true，否则返回false。</p>
<p><strong>hashCode</strong>()方法返回一个int数，在Object类中的默认实现是“将该对象的<strong>内部地址</strong>转换成一个整数返回”。</p>
<p><strong>如果只重写equals不重写hashcode会有问题吗？</strong></p>
<ul>
<li>会有问题，如果我们想按照其他规则来判断两个对象相等与否，此时只重写equals而不重写hashcode，那么在将数据存储入set、list等散列表中时，java会默认采用目标地址进行hashcode，这是，我们认为的两个相同的对象就可能放入不同的数组位置上了，这样就造成了数据的不唯一性。</li>
</ul>
<p><strong>补充</strong>：</p>
<p>当集合要添加新的元素时，可分为两个步骤：</p>
<ul>
<li>
<p>先调用这个元素的 hashCode 方法，然后根据所得到的值计算出元素应该在数组的位置。如果这个位置上没有元素，那么直接将它存储在这个位置上；</p>
</li>
<li>
<p>如果这个位置上已经有元素了，那么调用它的equals方法与新元素进行比较：相同的话就不存了，否则，将其存在这个位置对应的链表中（Java 中 HashSet, HashMap 和 Hashtable的实现总将元素放到链表的表头）。</p>
</li>
</ul>
<h1 id="2树"><a class="markdownIt-Anchor" href="#2树"></a> 2.树</h1>
<h2 id="二叉搜索树二叉查找树"><a class="markdownIt-Anchor" href="#二叉搜索树二叉查找树"></a> 二叉搜索树（二叉查找树）</h2>
<p>二叉查找树具有的特性：</p>
<ol>
<li>左子树上所有结点的值均小于或等于它的根结点的值。</li>
<li>右子树上所有结点的值均大于或等于它的根结点的值。</li>
<li>左、右子树也分别为二叉排序树。</li>
</ol>
<h2 id="二叉平衡树alv"><a class="markdownIt-Anchor" href="#二叉平衡树alv"></a> 二叉平衡树（ALV）</h2>
<ol>
<li>
<p><strong>什么是二叉平衡树呢？</strong><br>
1.具有二叉查找树的全部特性。</p>
<p>2.每个节点的左子树和右子树的高度差至多为1。<br>
<img src="/2023/02/17/javase/image-20230406172947233.png" alt="image-20230406172947233"><br>
平衡树基于这种特点就可以保证不会出现大量节点偏向于一边的情况了!（插入或者删除时，会发生左旋、右旋操作，使这棵树再次左右保持一定的平衡)</p>
</li>
</ol>
<p><strong>为什么有了平衡树还需要红黑树呢？</strong></p>
<p>虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在O(logn)，不过却不是最佳的。</p>
<p>因为平衡树要求每个节点的左子树和右子树的高度差至多等于1，这个要求实在是太严了，导致每次进行插入删除节点的时候几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。</p>
<p>显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树!</p>
<h2 id="红黑树"><a class="markdownIt-Anchor" href="#红黑树"></a> 红黑树</h2>
<p>红黑树一种自平衡的二叉查找树。除了具有二叉查找的特性外，还具有的特性：</p>
<ul>
<li>节点是红色或黑色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点都是黑色的空节点(NIL节点)。</li>
<li>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ul>
<p><strong>hashmap为什么不使用AVL树而使用红黑树？</strong></p>
<ul>
<li>
<p>红黑树和AVL树都是<strong>最常用的平衡二叉搜索树</strong>，它们的查找、删除、修改都是O(lgn) time</p>
</li>
<li>
<p>AVL树和红黑树有几点比较和区别：<br>
（1）AVL树是更加严格的平衡，因此可以提供更快的查找速度，一般读取查找密集型任务，适用AVL树。<br>
（2）红黑树更适合于插入修改密集型任务。<br>
（3）通常，AVL树的旋转比红黑树的旋转更加难以平衡和调试。</p>
</li>
<li>
<p><strong>在CurrentHashMap中是加锁了的，实际上是读写锁，如果写冲突就会等待，<br>
如果插入时间过长必然等待时间更长，而红黑树相对AVL树他的插入更快！</strong></p>
</li>
</ul>
<h1 id="3java异常体系"><a class="markdownIt-Anchor" href="#3java异常体系"></a> 3.java异常体系</h1>
<p><img src="/2023/02/17/javase/image-20230406173037693.png" alt="image-20230406173037693"></p>
<p><img src="/2023/02/17/javase/image-20230406173048904.png" alt="image-20230406173048904"></p>
<p><strong>java异常体系</strong></p>
<ul>
<li>
<p><strong>Thorwable</strong>类（表示可抛出）是所有异常和错误的超类，两个直接子类为<strong>Error</strong>和<strong>Exception</strong>，分别表示错误和异常。</p>
</li>
<li>
<p>其中异常类<strong>Exception</strong>又分为运行时异常(<strong>RuntimeException</strong>)和非运行时异常， 这两种异常有很大的区别，也称之为不检查异常（<strong>Unchecked</strong> Exception）和检查异常（<strong>Checked</strong> Exception）。</p>
</li>
</ul>
<p><strong>Error与Exception</strong></p>
<ul>
<li>
<p><strong>Error</strong>错误：（这种错误无法处理）描述了Java运行时系统的内部错误和资源耗尽错误。一般是指虚拟机（JVM）相关的问题，如系统崩溃，虚拟机出错误等，这种错误无法恢复或不可能捕获，将导致应用程序中断，通常不处理。因为如果出现这样的内部错误，除了通告用户，并尽力使程序安全地终止之外，再也无能为力了。</p>
</li>
<li>
<p><strong>Exception</strong>异常：Java的异常分为两种，checked Exception（编译时异常也叫非运行时异常）和 RuntimeException（运行时异常）。</p>
</li>
</ul>
<p><strong>运行时异常与非运行时异常</strong></p>
<ul>
<li>
<p>运行时异常（逻辑方面）都是RuntimeException类及其子类异常，如<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
</li>
<li>
<p>非运行时异常（程序语法）是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如<code>IOException</code>、<code>SQLException</code>等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
</li>
</ul>
<p><strong>Java异常处理方法有</strong></p>
<ul>
<li><strong>抛出</strong>异常，<strong>捕捉</strong>异常。主要依赖于try、catch、finally、throw、throws五个关键字。</li>
</ul>
<h1 id="4面向对象"><a class="markdownIt-Anchor" href="#4面向对象"></a> 4.面向对象</h1>
<p><strong>面向对象理解</strong></p>
<ul>
<li>
<p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就 可以了。</p>
</li>
<li>
<p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p>
</li>
</ul>
<p><strong>面向过程理解</strong></p>
<ul>
<li>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</li>
</ul>
<p><strong>面向对象和面向过程的区别</strong></p>
<ul>
<li><strong>面向过程</strong>
<ul>
<li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、 嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li>
<li>缺点：没有面向对象易维护、易复用、易扩展</li>
</ul>
</li>
<li><strong>面向对象</strong>
<ul>
<li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出 低耦合的系统，使系统更加灵活、更加易于维护</li>
<li>缺点：性能比面向过程低</li>
</ul>
</li>
</ul>
<h1 id="5接口与抽象类"><a class="markdownIt-Anchor" href="#5接口与抽象类"></a> 5.接口与抽象类</h1>
<p><strong>成员区别</strong></p>
<ul>
<li>抽象类
<ul>
<li>构造方法：有构造方法，用于子类实例化使用。</li>
<li>成员变量：可以是变量，也可以是常量。</li>
<li>成员方法：可以是抽象的，也可以是非抽象的。</li>
</ul>
</li>
<li>接口
<ul>
<li>构造方法：没有构造方法</li>
<li>成员变量：只能是常量。默认修饰符：public static final</li>
<li>成员方法：jdk1.7只能是抽象的。默认修饰符：public abstract (推荐：默认修饰符请自己永远手动给出)</li>
<li>jdk1.8可以写以default和static开头的具体方法</li>
</ul>
</li>
</ul>
<p><strong>类与接口的关系区别</strong></p>
<ul>
<li>类与类
<ul>
<li>继承关系,只能单继承。可以多层继承。</li>
</ul>
</li>
<li>类与接口
<ul>
<li>实现关系,可以单实现,也可以多实现。</li>
<li>类还可以在继承一个类的同时实现多个接口。</li>
</ul>
</li>
<li>接口与接口
<ul>
<li>继承关系,可以单继承,也可以多继承。</li>
</ul>
</li>
</ul>
<p><strong>体现的理念不同</strong></p>
<ul>
<li>抽象类里面定义的都是一个继承体系中的共性内容。</li>
<li>接口是功能的集合,是一个体系额外的功能，是暴露出来的规则。</li>
</ul>
<p><strong>选择抽象类还是接口的依据</strong></p>
<ul>
<li>当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</li>
<li>抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度。</li>
</ul>
<h1 id="6静态变量和普通变量的区别"><a class="markdownIt-Anchor" href="#6静态变量和普通变量的区别"></a> 6.静态变量和普通变量的区别</h1>
<p><strong>所属目标不同</strong></p>
<ul>
<li>静态变量属于类的变量，普通变量属于对象的变量。</li>
</ul>
<p><strong>存储区域不同</strong></p>
<ul>
<li>静态变量存储在方法区的静态区，普通变量存储在堆区。</li>
</ul>
<p><strong>加载时间不同</strong></p>
<ul>
<li>静态变量是随时类的加载而加载的，随着类的消失而消失。</li>
<li>普通变量是随着对象的加载而加载，随着对象的消失而消失。</li>
</ul>
<p><strong>调用方式不同</strong></p>
<ul>
<li>静态变量只能通过类名，对象调用。</li>
<li>普通变量只能通过对象调用。</li>
</ul>
<p><strong>static可以修饰局部变量么？</strong></p>
<ul>
<li>不能是局部变量，可以是内部类，全局变量，方法，代码块。</li>
</ul>
<h1 id="7有了int为什么还要integer"><a class="markdownIt-Anchor" href="#7有了int为什么还要integer"></a> 7.有了int为什么还要Integer</h1>
<p>主要是因为面向对象的思想，因为Java语言是面向对象的，这也是它只所以流行的原因之一，对象封装有很多好处，可以把属性也就是数据跟处理这些数据的方法结合在一起，比如Integer就有parseInt()等方法来专门处理int型相关的数据，</p>
<p>另一个非常重要的原因就是在Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，也就是Integer才能被List所接受。所以Integer的存在是很必要的。</p>
<h1 id="8java泛型的好处及底层原理"><a class="markdownIt-Anchor" href="#8java泛型的好处及底层原理"></a> 8.Java泛型的好处及底层原理</h1>
<p><strong>泛型好处</strong></p>
<ul>
<li>保证了类型的安全性，泛型可以使编译器知道一个对象的限定类型是什么，这样编译器就可以在一个高的程度上验证这个类型</li>
<li>消除了强制类型转换 使得代码可读性好，减少了很多出错的机会</li>
<li>泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</li>
<li>避免了不必要的装箱、拆箱操作，提高程序的性能</li>
</ul>
<p><strong>实现原理</strong></p>
<ul>
<li>泛型的实现是靠类型擦除技术 类型擦除是在编译期完成的 也就是在编译期 编译器会将泛型的类型参数都擦除成它的限定类型，如果没有则擦除为object类型之后在获取的时候再强制类型转换为对应的类型。</li>
<li>如果构建泛型实例时使用了泛型语法，那么编译器将标记该实例并关注该实例后续所有方法的调用，每次调用前都进行安全检查，非指定类型的方法都不能调用成功。</li>
</ul>
<h1 id="9java定时器实现"><a class="markdownIt-Anchor" href="#9java定时器实现"></a> 9.java定时器实现</h1>
<h2 id="使用timer和和timertask类"><a class="markdownIt-Anchor" href="#使用timer和和timertask类"></a> <strong>使用Timer和和TimerTask类</strong></h2>
<p>1、Timer和TimerTask是java.util包下的类，用于实现定时任务</p>
<p>步骤1：创建TimerTask定时器任务，可以通过匿名内部类的方式创建</p>
<p>步骤2：创建Timer定时器，调用定时器的方法执行定时器任务</p>
<p>2、Timer的两个方法schedule()和scheduleAtFixedRate()及其重载方法：</p>
<blockquote>
<p>void schedule(TimerTask task, long delay)：在指定时间后执行1次任务，其中delay表示时延，单位是毫秒，设置为1000，则表示1秒后执行一次定时器任务；</p>
<p>void schedule(TimerTask task, long delay, long period)：指定延迟指定时间后周期性地执行任务（delay毫秒后，每period毫秒执行一次）</p>
<p>void scheduleAtFixedRate(TimerTask task, long delay, long period)：指定延迟指定时间后周期性地执行任务（delay毫秒后，每period毫秒执行一次）</p>
<p>void scheduleAtFixedRate(TimerTask task, Date firstTime,long period) ：从指定日期firstTime开始，每period毫秒执行一次任务</p>
</blockquote>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建定时器</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="comment">// 创建定时器任务</span></span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        timer.schedule(timerTask, <span class="number">1000</span>); <span class="comment">// 1秒后执行一次</span></span><br><span class="line">        timer.schedule(timerTask, <span class="number">2000</span>, <span class="number">2000</span>); <span class="comment">// 两秒后每两秒执行一次</span></span><br><span class="line">        timer.scheduleAtFixedRate(timerTask, <span class="number">3000</span>, <span class="number">3000</span>); <span class="comment">// 3秒后每3秒执行一次</span></span><br><span class="line">        timer.scheduleAtFixedRate(task, <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="number">4000</span>); <span class="comment">// 每4秒执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用线程池"><a class="markdownIt-Anchor" href="#使用线程池"></a> <strong>使用线程池</strong></h2>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建定时器任务</span></span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">        scheduledThreadPool.schedule(timerTask, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(timerTask, <span class="number">1000</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用spring-task"><a class="markdownIt-Anchor" href="#使用spring-task"></a> 使用Spring Task</h2>
<p>步骤1：在springBoot启动类上添加@EnableScheduling注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤2：创建一个定时任务类的bean，在类的方法上使用@Schedule注解，通过注解的cron属性设置定时器的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 7 2 26 7 *&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;定时任务...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码指定在2022年7月26日02:07:00执行一次定时任务</p>
<h2 id="通过quartz任务调度工具"><a class="markdownIt-Anchor" href="#通过quartz任务调度工具"></a> 通过Quartz任务调度工具</h2>
<p>步骤1：在pom.xml中添加quartz的依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>步骤2：创建quartz的配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个JobDetail(工作详情)类对象,保存到Spring容器中，这个类用于封装我们编写的job接口实现类</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JobDetail <span class="title function_">jobDetail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;showTime方法运行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(QuartzJob.class)   <span class="comment">// 绑定要运行的任务类的类对象</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;job&quot;</span>)               <span class="comment">// 设置job的名称</span></span><br><span class="line">                .storeDurably()                     <span class="comment">// 信息持久</span></span><br><span class="line">                <span class="comment">// 设置storeDurably之后,当没有触发器指向这个JobDetail时,JobDetail也不会从</span></span><br><span class="line">                <span class="comment">// Spring容器中删除,如果不设置这行,就会自动从Spring容器中删除</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 声明触发器，触发器决定我们的工作\任务何时触发</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Trigger <span class="title function_">trigger</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;showTime触发器运行&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 定义Cron表达式，每分钟触发一次</span></span><br><span class="line">    <span class="type">CronScheduleBuilder</span> <span class="variable">cronScheduleBuilder</span> <span class="operator">=</span> </span><br><span class="line">            CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/10 * * * * ?&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> TriggerBuilder.newTrigger()</span><br><span class="line">            .forJob(jobDetail()) <span class="comment">// 绑定JobDetail对象</span></span><br><span class="line">            .withIdentity(<span class="string">&quot;trigger&quot;</span>) <span class="comment">// 定义触发器名称</span></span><br><span class="line">            .withSchedule(cronScheduleBuilder) <span class="comment">// 绑定Cron表达式</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>}</p>
<p>步骤:3：定义Job</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> &#123;</span><br><span class="line">        <span class="comment">// 输出当前时间</span></span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="10java中有哪些队列"><a class="markdownIt-Anchor" href="#10java中有哪些队列"></a> 10.java中有哪些队列</h1>
<p>Java 中的队列可以从不同的维度进行分类，例如可以从阻塞和非阻塞进行分类，也可以从有界和无界进行分类，而这里将从队列的功能上进行分类，例如：优先队列、普通队列、双端队列、延迟队列等。</p>
<p><img src="/2023/02/17/javase/image-20230406173105983.png" alt="image-20230406173105983"></p>
<ul>
<li>
<p><strong>普通队列</strong></p>
<ul>
<li>普通队列（Queue）是指实现了先进先出的基本队列，例如 <code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code>，其中 <code>ArrayBlockingQueue</code> 是用数组实现的普通队列，而 <code>LinkedBlockingQueue</code> 是使用链表实现的普通队列</li>
</ul>
</li>
<li>
<p><strong>双端队列</strong></p>
<ul>
<li>双端队列（Deque）是指队列的头部和尾部都可以同时入队和出队的数据结构。例如：LinkedBlockingDeque</li>
</ul>
</li>
<li>
<p><strong>优先队列</strong></p>
<ul>
<li>
<p>优先队列（PriorityQueue）是一种特殊的队列，它并不是先进先出的，而是优先级高的元素先出队。</p>
</li>
<li>
<p>优先队列是根据二叉堆实现的，二叉堆的数据结构如下图所示：</p>
<p><img src="/2023/02/17/javase/image-20230406173112557.png" alt="image-20230406173112557"></p>
<p>二叉堆分为两种类型：一种是最大堆一种是最小堆。以上展示的是最大堆，<strong>在最大堆中，任意一个父节点的值都大于等于它左右子节点的值。</strong></p>
<blockquote>
<p>因为优先队列是基于二叉堆实现的，因此它可以将优先级最好的元素先出队。</p>
</blockquote>
</li>
<li>
<p><strong>优先队列的出队是不考虑入队顺序的，它始终遵循的是优先级高的元素先出队</strong>。</p>
</li>
</ul>
</li>
<li>
<p><strong>延迟队列</strong></p>
<ul>
<li>延迟队列（DelayQueue）是基于优先队列 <code>PriorityQueue</code> 实现的，它可以看作是一种以时间为度量单位的优先的队列，当入队的元素到达指定的延迟时间之后方可出队。</li>
</ul>
</li>
<li>
<p><strong>其他队列</strong>（例如SynchronousQueue同步移交队列）</p>
<ul>
<li>在 Java 的队列中有一个比较特殊的队列 <code>SynchronousQueue</code>，它的特别之处在于它内部没有容器，每次进行 <code>put()</code> 数据后（添加数据），必须等待另一个线程拿走数据后才可以再次添加数据</li>
</ul>
</li>
</ul>
<h1 id="11获取类中私有属性"><a class="markdownIt-Anchor" href="#11获取类中私有属性"></a> 11.获取类中私有属性</h1>
<p><strong>通过反射获得</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取学生类的字节码对象</span></span><br><span class="line">Class clazzClass=Class.forName(<span class="string">&quot;com.test2.Student&quot;</span>);</span><br><span class="line"><span class="comment">//获取学生对象</span></span><br><span class="line">Object stuObject=clazzClass.newInstance();</span><br><span class="line"><span class="comment">//获取私有的字段对象</span></span><br><span class="line">Field field=clazzClass.getDeclaredField(<span class="string">&quot;nameString&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);<span class="comment">//设置发射时取消Java的访问检查，暴力访问</span></span><br><span class="line">System.out.println(field);</span><br><span class="line">field.set(stuObject, <span class="string">&quot;桂贤松&quot;</span>);</span><br><span class="line">System.out.println(stuObject);<span class="comment">//获取的是地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使其获取到值</span></span><br><span class="line">Object nameObject=field.get(stuObject);</span><br><span class="line">System.out.println(nameObject);</span><br></pre></td></tr></table></figure>
<h1 id="12分布式事务"><a class="markdownIt-Anchor" href="#12分布式事务"></a> 12.分布式事务</h1>
<p>满足<strong>ACID</strong>（原子性、一致性、隔离性、持久性）的一组操作，可以被称为一个事务。随着计算机系统的发展，越来越多的采用分布式的架构来对外提供服务，但是，不同的机器的处理性能、存储性能、网络状态等各有不同，让分布式集群始终对外提供可用的一致性服务一直是需要处理的问题。</p>
<p>为了保证数据变更请求在整个分布式环境下正确地执行，不会导致部分服务器暂时崩溃导致整个集群提供的服务和数据不再相同，在整个分布式系统处理数据变更请求的过程中，需要引入分布式事务的概念。常见的提交方式有<strong>二阶段提交</strong>（Two-phase Commit，2PC）和<strong>三阶段提交</strong>（Three-phase commit，3PC）。</p>
<h2 id="二阶段提交"><a class="markdownIt-Anchor" href="#二阶段提交"></a> 二阶段提交</h2>
<p>2PC，两阶段提交，将事务的提交过程分为资源准备和资源提交两个阶段，并且由事务协调者来协调所有事务参与者，如果准备阶段所有事务参与者都预留资源成功，则进行第二阶段的资源提交，否则事务协调者回滚资源。</p>
<p>第一阶段：</p>
<img src="/2023/02/17/javase/image-20230406173122348.png" alt="image-20230406173122348" style="zoom: 67%;">
<p>在XA分布式事务的第一阶段，作为事务协调者的节点会首先向所有的参与者节点发送Prepare请求。</p>
<p>在接到Prepare请求之后，每一个参与者节点会各自执行与事务有关的数据更新，写入Undo Log和Redo Log。如果参与者执行成功，暂时不提交事务，而是向事务协调节点返回“完成”消息。</p>
<p>当事务协调者接到了所有参与者的返回消息，整个分布式事务将会进入第二阶段。</p>
<p>第二阶段：</p>
<img src="/2023/02/17/javase/image-20230406173143746.png" alt="image-20230406173143746" style="zoom:67%;">
<p>在XA分布式事务的第二阶段，如果事务协调节点在之前所收到都是正向返回，那么它将会向所有事务参与者发出Commit请求。</p>
<p>接到Commit请求之后，事务参与者节点会各自进行本地的事务提交，并释放锁资源。当本地事务完成提交后，将会向事务协调者返回“完成”消息。</p>
<p>当事务协调者接收到所有事务参与者的“完成”反馈，整个分布式事务完成。</p>
<p>以上所描述的是XA两阶段提交的正向流程，接下来我们看一看失败情况的处理流程：</p>
<p>第一阶段：</p>
<img src="/2023/02/17/javase/image-20230406173155292.png" alt="image-20230406173155292" style="zoom:67%;">
<p>第二阶段：</p>
<img src="/2023/02/17/javase/image-20230406173205323.png" alt="image-20230406173205323" style="zoom:67%;">
<p>在XA的第一阶段，如果某个事务参与者反馈失败消息，说明该节点的本地事务执行不成功，必须回滚。</p>
<p>于是在第二阶段，事务协调节点向所有的事务参与者发送Abort请求。接收到Abort请求之后，各个事务参与者节点需要在本地进行事务的回滚操作，回滚操作依照Undo Log来进行。</p>
<p><strong>两阶段提交的不足</strong></p>
<ul>
<li>
<p>1.性能问题</p>
<ul>
<li>XA协议遵循强一致性。在事务执行过程中，各个节点占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知提交，参与者提交后释放资源。这样的过程有着非常明显的性能问题。</li>
</ul>
</li>
<li>
<p>2.协调者单点故障问题</p>
<ul>
<li>事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，参与者收不到提交或是回滚通知，参与者会一直处于中间状态无法完成事务。</li>
</ul>
</li>
<li>
<p>3.丢失消息导致的不一致问题。</p>
<ul>
<li>在XA协议的第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。</li>
</ul>
</li>
<li>
<p>二阶段无法解决的问题</p>
<ul>
<li>协调者在发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了，那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li>
</ul>
</li>
</ul>
<h2 id="三阶段提交"><a class="markdownIt-Anchor" href="#三阶段提交"></a> 三阶段提交</h2>
<p>3PC，三阶段提交协议，是二阶段提交协议的改进版本，三阶段提交有两个改动点：</p>
<p>（1）在协调者和参与者中都引入超时机制<br>
（2）在第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。<br>
所以3PC会分为3个阶段，CanCommit 准备阶段、PreCommit 预提交阶段、DoCommit 提交阶段，处理流程如下：</p>
<img src="/2023/02/17/javase/image-20230406173326661.png" alt="image-20230406173326661">
<p><strong>1、阶段一：CanCommit 准备阶段</strong></p>
<p>​        协调者向参与者发送 canCommit 请求，参与者如果可以提交就返回Yes响应，否则返回No响应，具体流程如下：</p>
<ul>
<li>
<p>（1）事务询问：协调者向所有参与者发出包含事务内容的 canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。</p>
</li>
<li>
<p>（2）响应反馈：参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。</p>
</li>
</ul>
<p><strong>2、阶段二：PreCommit 阶段</strong></p>
<p>​        协调者根据参与者的反应情况来决定是否可以进行事务的 PreCommit 操作。根据响应情况，有以下两种可能：</p>
<p><strong>（1）执行事务：</strong></p>
<p>假如所有参与者均反馈 yes，协调者预执行事务，具体如下：</p>
<ul>
<li>① 发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入准备阶段</li>
<li>② 事务预提交 ：参与者接收到 PreCommit 请求后，会执行本地事务操作，并将 undo 和 redo 信息记录到事务日志中（但不提交事务）</li>
<li>③ 响应反馈 ：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</li>
</ul>
<p><img src="/2023/02/17/javase/image-20230406173356533.png" alt="image-20230406173356533"></p>
<p><strong>（2）中断事务：</strong></p>
<p>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断，流程如下：</p>
<ul>
<li>① 发送中断请求 ：协调者向所有参与者发送 abort 请求。</li>
<li>② 中断事务 ：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li>
</ul>
<p><img src="/2023/02/17/javase/image-20230406173404344.png" alt="image-20230406173404344"></p>
<p><strong>3、阶段三：doCommit阶段</strong></p>
<p>该阶段进行真正的事务提交，也可以分为以下两种情况：</p>
<p><strong>（1）提交事务：</strong></p>
<ul>
<li>① 发送提交请求：协调接收到所有参与者发送的ACK响应，那么他将从预提交状态进入到提交状态，并向所有参与者发送 doCommit 请求</li>
<li>② 本地事务提交：参与者接收到doCommit请求之后，执行正式的事务提交，并在完成事务提交之后释放所有事务资源</li>
<li>③ 响应反馈：事务提交完之后，向协调者发送ack响应。</li>
<li>④ 完成事务：协调者接收到所有参与者的ack响应之后，完成事务。</li>
</ul>
<p><img src="/2023/02/17/javase/image-20230406173416188.png" alt="image-20230406173416188"></p>
<p><strong>（2）中断事务：</strong></p>
<p>任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务</p>
<ul>
<li>
<p>① 发送中断请求：如果协调者处于工作状态，向所有参与者发出 abort 请求</p>
</li>
<li>
<p>② 事务回滚：参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p>
</li>
<li>
<p>③ 反馈结果：参与者完成事务回滚之后，向协调者反馈ACK消息</p>
</li>
<li>
<p>④ 中断事务：协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p>
<pre><code>  进入doCommit阶段后，无论协调者出现问题，或者协调者与参与者之间的网络出现问题，都会导致参与者无法接收到协调者发出的 doCommit 请求或 abort 请求。此时，参与者都会在等待超时之后，继续执行事务提交。这其实基于概率来决定的，当进入第三阶段时，说明第一阶段收到所有参与者的CanCommit响应都是Yes，意味着大家都同意修改了，并且第二阶段所有的参与者对协调者的PreCommit请求也都是同意的。所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。
</code></pre>
</li>
</ul>
<p><strong>3PC的优缺点：</strong></p>
<p>与2PC相比，3PC降低了阻塞范围，并且在等待超时后，协调者或参与者会中断事务，避免了协调者单点问题，阶段三中协调者出现问题时，参与者会继续提交事务。</p>
<p>​    数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 doCommit 指令时，此时如果协调者请求中断事务，而协调者因为网络问题无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2PC和3PC都无法保证数据绝对的一致性，一般为了预防这种问题，可以添加一个报警，比如监控到事务异常的时候，通过脚本自动补偿差异的信息。</span><br></pre></td></tr></table></figure>
<h2 id="ttc"><a class="markdownIt-Anchor" href="#ttc"></a> TTC</h2>
<p><strong>1、什么是TCC</strong>：<br>
TCC（Try Confirm Cancel）是应用层的两阶段提交，所以对代码的侵入性强，其核心思想是：针对每个操作，都要实现对应的确认和补偿操作，也就是业务逻辑的每个分支都需要实现 try、confirm、cancel 三个操作，第一阶段由业务代码编排来调用Try接口进行资源预留，当所有参与者的 Try 接口都成功了，事务协调者提交事务，并调用参与者的 confirm 接口真正提交业务操作，否则调用每个参与者的 cancel 接口回滚事务，并且由于 confirm 或者 cancel 有可能会重试，因此对应的部分需要支持幂等。</p>
<p><strong>2、TCC的执行流程</strong>：</p>
<p>​        TCC的执行流程可以分为两个阶段，分别如下：</p>
<ul>
<li>
<p>（1）第一阶段：Try，业务系统做检测并预留资源 (加锁，锁住资源)，比如常见的下单，在try阶段，我们不是真正的减库存，而是把下单的库存给锁定住。</p>
</li>
<li>
<p>（2）第二阶段：根据第一阶段的结果决定是执行confirm还是cancel</p>
<ul>
<li>Confirm：执行真正的业务（执行业务，释放锁）</li>
<li>Cancle：是对Try阶段预留资源的释放（出问题，释放锁）</li>
</ul>
</li>
</ul>
<p><img src="/2023/02/17/javase/image-20230406173428455.png" alt="image-20230406173428455"></p>
<p><strong>3、TCC如何保证最终一致性</strong>：</p>
<ul>
<li>TCC 事务机制以 Try 为中心的，Confirm 确认操作和 Cancel 取消操作都是围绕 Try 而展开。因此，Try 阶段中的操作，其保障性是最好的，即使失败，仍然有 Cancel 取消操作可以将其执行结果撤销。</li>
<li>Try阶段执行成功并开始执行 Confirm 阶段时，默认 Confirm 阶段是不会出错的，也就是说只要 Try 成功，Confirm 一定成功（TCC设计之初的定义）</li>
<li>Confirm 与 Cancel 如果失败，由TCC框架进行重试补偿存在极低概率在CC环节彻底失败，则需要定时任务或人工介入</li>
</ul>
<p><strong>4、TCC的注意事项</strong>：</p>
<ul>
<li>
<p>（1）<strong>允许空回滚</strong>：</p>
<pre><code>  空回滚出现的原因是 Try 超时或者丢包，导致 TCC 分布式事务二阶段的 回滚，触发 Cancel 操作，此时事务参与者未收到Try，但是却收到了Cancel 请求。
  所以 cancel 接口在实现时需要允许空回滚，也就是 Cancel 执行时如果发现没有对应的事务 xid 或主键时，需要返回回滚成功，让事务服务管理器认为已回滚。
</code></pre>
</li>
<li>
<p>（2）<strong>防悬挂控制</strong>：</p>
<pre><code>  悬挂指的是二阶段的 Cancel 比 一阶段的Try 操作先执行，出现该问题的原因是 Try 由于网络拥堵而超时，导致事务管理器生成回滚，触发 Cancel 接口，但之后拥堵在网络的 Try 操作又被资源管理器收到了，但是 Cancel 比 Try 先到。但按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，所以此时应该拒绝执行空回滚之后到来的 Try 操作，否则会产生数据不一致。因此我们可以在 Cancel 空回滚返回成功之前，先记录该条事务 xid 或业务主键，标识这条记录已经回滚过，Try 接口执行前先检查这条事务xid或业务主键是否已经标记为回滚成功，如果是则不执行 Try 的业务操作。
</code></pre>
</li>
<li>
<p>（3）<strong>幂等控制</strong>：</p>
<pre><code>  由于网络原因或者重试操作都有可能导致 Try - Confirm - Cancel 3个操作的重复执行，所以使用 TCC 时需要注意这三个操作的幂等控制，通常我们可以使用事务 xid 或业务主键判重来控制。
</code></pre>
</li>
</ul>
<p><strong>5、TCC方案的优缺点</strong>：</p>
<ul>
<li>（1）TCC 事务机制相比于上面介绍的 XA 事务机制，有以下优点：
<ul>
<li>性能提升：具体业务来实现，控制资源锁的粒度变小，不会锁定整个资源。</li>
<li>数据最终一致性：基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。</li>
<li>可靠性：解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。</li>
</ul>
</li>
<li>（2）缺点
<ul>
<li>TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。</li>
</ul>
</li>
</ul>
<h2 id="saga事务"><a class="markdownIt-Anchor" href="#saga事务"></a> Saga事务</h2>
<p><strong>1、什么是Saga事务</strong>：</p>
<p>​        Saga 事务核心思想是将长事务拆分为多个本地短事务并依次正常提交，如果所有短事务均执行成功，那么分布式事务提交；如果出现某个参与者执行本地事务失败，则由 Saga 事务协调器协调根据相反顺序调用补偿操作，回滚已提交的参与者，使分布式事务回到最初始的状态。Saga 事务基本协议如下：</p>
<ul>
<li>（1）每个 Saga 事务由一系列幂等的有序子事务(sub-transaction) Ti 组成。</li>
<li>（2）每个 Ti 都有对应的幂等补偿动作 Ci，补偿动作用于撤销 Ti 造成的结果。</li>
</ul>
<p>与TCC事务补偿机制相比，TCC有一个预留(Try)动作，相当于先报存一个草稿，然后才提交；Saga事务没有预留动作，直接提交。</p>
<p><strong>2、Saga的恢复策略</strong>：</p>
<p>对于事务异常，Saga提供了两种恢复策略，分别如下：</p>
<p><strong>（1）向后恢复(backward recovery)</strong>：</p>
<p>当执行事务失败时，补偿所有已完成的事务，是“一退到底”的方式，这种做法的效果是撤销掉之前所有成功的子事务，使得整个 Saga 的执行结果撤销。如下图：</p>
<p><img src="/2023/02/17/javase/image-20230406173437114.png" alt="image-20230406173437114"></p>
<pre><code>     从上图可知事务执行到了支付事务T3，但是失败了，因此事务回滚需要从C3,C2,C1依次进行回滚补偿，对应的执行顺序为：T1,T2,T3,C3,C2,C1。
</code></pre>
<p><strong>（2）向前恢复(forward recovery)</strong>：</p>
<p>​    对于执行不通过的事务，会尝试重试事务，这里有一个假设就是每个子事务最终都会成功，这种方式适用于必须要成功的场景，事务失败了重试，不需要补偿。流程如下图：</p>
<p><img src="/2023/02/17/javase/image-20230406173443142.png" alt="image-20230406173443142"></p>
<p><strong>3、Saga事务的实现方式</strong>：</p>
<p>Saga事务有两种不同的实现方式，分别如下：</p>
<ul>
<li>命令协调（Order Orchestrator）</li>
<li>事件编排（Event Choreographyo）</li>
</ul>
<p><strong>（1）命令协调</strong>：</p>
<p>​    中央协调器（Orchestrator，简称 OSO）以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。整体流程如下图：</p>
<p><img src="/2023/02/17/javase/image-20230406173449490.png" alt="image-20230406173449490"></p>
<ul>
<li>① 事务发起方的主业务逻辑请求 OSO 服务开启订单事务</li>
<li>② OSO 向库存服务请求扣减库存，库存服务回复处理结果。</li>
<li>③ OSO 向订单服务请求创建订单，订单服务回复创建结果。</li>
<li>④ OSO 向支付服务请求支付，支付服务回复处理结果。</li>
<li>⑤ 主业务逻辑接收并处理 OSO 事务处理结果回复。</li>
</ul>
<p>​        中央协调器 OSO 必须事先知道执行整个事务所需的流程，如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚，基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。</p>
<p><strong>（2）事件编排</strong>：</p>
<p>​    命令协调方式基于中央协调器实现，所以有单点风险，但是事件编排方式没有中央协调器。事件编排的实现方式中，每个服务产生自己的时间并监听其他服务的事件来决定是否应采取行动。</p>
<p>​    在事件编排方法中，第一个服务执行一个事务，然后发布一个事件，该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何 Saga 参与者听到都意味着事务结束。</p>
<p><img src="/2023/02/17/javase/image-20230406173457167.png" alt="image-20230406173457167"></p>
<ul>
<li>
<p>① 事务发起方的主业务逻辑发布开始订单事件。</p>
</li>
<li>
<p>② 库存服务监听开始订单事件，扣减库存，并发布库存已扣减事件。</p>
</li>
<li>
<p>③ 订单服务监听库存已扣减事件，创建订单，并发布订单已创建事件。</p>
</li>
<li>
<p>④ 支付服务监听订单已创建事件，进行支付，并发布订单已支付事件。</p>
</li>
<li>
<p>⑤ 主业务逻辑监听订单已支付事件并处理。</p>
<p>如果事务涉及 2 至 4 个步骤，则非常合适使用事件编排方式，它是实现 Saga 模式的自然方式，它很简单，容易理解，不需要太多的代码来构建。</p>
</li>
</ul>
<p><strong>4、Saga事务的优缺点</strong>：</p>
<p><strong>（1）命令协调设计的优缺点</strong>：</p>
<p>① 优点：</p>
<ul>
<li>服务之间关系简单，避免服务间循环依赖，因为 Saga 协调器会调用 Saga 参与者，但参与者不会调用协调器。</li>
<li>程序开发简单，只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。</li>
<li>易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试。</li>
</ul>
<p>② 缺点：</p>
<ul>
<li>中央协调器处理逻辑容易变得庞大复杂，导致难以维护。</li>
<li>存在协调器单点故障风险。</li>
</ul>
<p><strong>（2）事件编排设计的优缺点</strong>：</p>
<p>① 优点：</p>
<ul>
<li>避免中央协调器单点故障风险。</li>
<li>当涉及的步骤较少服务开发简单，容易实现。</li>
</ul>
<p>② 缺点：</p>
<ul>
<li>服务之间存在循环依赖的风险。</li>
<li>当涉及的步骤较多，服务间关系混乱，难以追踪调测。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于 Saga 模型没有 Prepare 阶段，因此事务间不能保证隔离性。当多个 Saga 事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：在应用层面加锁，或者应用层面预先冻结资源。</span><br></pre></td></tr></table></figure>
<h2 id="本地消息表"><a class="markdownIt-Anchor" href="#本地消息表"></a> 本地消息表</h2>
<p><strong>1、什么是本地消息表</strong>：<br>
本地消息表的核心思路就是将分布式事务拆分成本地事务进行处理，在该方案中主要有两种角色：事务主动方和事务被动方。事务主动发起方需要额外新建事务消息表，并在本地事务中完成业务处理和记录事务消息，并轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</p>
<p>​    这样可以避免以下两种情况导致的数据不一致性：</p>
<ul>
<li>业务处理成功、事务消息发送失败</li>
<li>业务处理失败、事务消息发送成功</li>
</ul>
<p><strong>2、本地消息表的执行流程</strong>：</p>
<p><img src="/2023/02/17/javase/image-20230406173505430.png" alt="image-20230406173505430"></p>
<ul>
<li>① 事务主动方在同一个本地事务中处理业务和写消息表操作</li>
<li>② 事务主动方通过消息中间件，通知事务被动方处理事务消息。消息中间件可以基于 Kafka、RocketMQ 消息队列，事务主动方主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。</li>
<li>③ 事务被动方通过消息中间件，通知事务主动方事务已处理的消息。</li>
<li>④ 事务主动方接收中间件的消息，更新消息表的状态为已处理。</li>
</ul>
<p>一些必要的容错处理如下：</p>
<ul>
<li>当①处理出错，由于还在事务主动方的本地事务中，直接回滚即可</li>
<li>当②、③处理出错，由于事务主动方本地保存了消息，只需要轮询消息重新通过消息中间件发送，通知事务被动方重新读取消息处理业务即可。</li>
<li>如果是业务上处理失败，事务被动方可以发消息给事务主动方回滚事务</li>
<li>如果事务被动方已经消费了消息，事务主动方需要回滚事务的话，需要发消息通知事务主动方进行回滚事务。</li>
</ul>
<p><strong>3、本地消息表的优缺点</strong>：</p>
<p>（1）优点：</p>
<ul>
<li>从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。<br>
方案轻量，容易实现。</li>
</ul>
<p>（2）缺点：</p>
<ul>
<li>与具体的业务场景绑定，耦合性强，不可公用</li>
<li>消息数据与业务数据同库，占用业务系统资源</li>
<li>业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限</li>
</ul>
<p>##　MQ事务消息</p>
<p>1、MQ事务消息的执行流程：</p>
<p>​        基于MQ的分布式事务方案本质上是对本地消息表的封装，整体流程与本地消息表一致，唯一不同的就是将本地消息表存在了MQ内部，而不是业务数据库中，如下图：</p>
<p><img src="/2023/02/17/javase/image-20230406173512991.png" alt="image-20230406173512991"></p>
<p>​     由于将本地消息表存在了MQ内部，那么MQ内部的处理尤为重要，下面主要基于 RocketMQ4.3 之后的版本介绍 MQ 的分布式事务方案</p>
<p><strong>2、RocketMQ事务消息</strong>：</p>
<p>​        在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，而 RocketMQ 的事务消息相对于普通 MQ提供了 2PC 的提交接口，方案如下：</p>
<p><img src="/2023/02/17/javase/image-20230406173519522.png" alt="image-20230406173519522"></p>
<p><strong>（1）正常情况</strong>：</p>
<p>在事务主动方服务正常，没有发生故障的情况下，发消息流程如下：</p>
<ul>
<li>步骤①：发送方向 MQ Server(MQ服务方)发送 half 消息</li>
<li>步骤②：MQ Server 将消息持久化成功之后，向发送方 ack 确认消息已经发送成功</li>
<li>步骤③：发送方开始执行本地事务逻辑</li>
<li>步骤④：发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。</li>
<li>最终步骤：MQ Server 如果收到的是 commit 操作，则将半消息标记为可投递，MQ订阅方最终将收到该消息；若收到的是 rollback 操作则删除 half 半消息，订阅方将不会接受该消息</li>
</ul>
<p><strong>（2）异常情况</strong>：</p>
<p>在断网或者应用重启等异常情况下，图中的步骤④提交的二次确认超时未到达 MQ Server，此时的处理逻辑如下：</p>
<ul>
<li>步骤⑤：MQ Server 对该消息发起消息回查</li>
<li>步骤⑥：发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果</li>
<li>步骤⑦：发送方根据检查得到的本地事务的最终状态再次提交二次确认。</li>
<li>最终步骤：MQ Server基于 commit/rollback 对消息进行投递或者删除。</li>
</ul>
<p><strong>3、MQ事务消息的优缺点</strong>：</p>
<p>（1）优点：相比本地消息表方案，MQ 事务方案优点是：</p>
<ul>
<li>消息数据独立存储 ，降低业务系统与消息系统之间的耦合</li>
<li>吞吐量大于使用本地消息表方案</li>
</ul>
<p>（2）缺点：</p>
<ul>
<li>一次消息发送需要两次网络请求(half 消息 + commit/rollback 消息) 。</li>
<li>业务处理服务需要实现消息状态回查接口。</li>
</ul>
<h2 id="最大努力通知"><a class="markdownIt-Anchor" href="#最大努力通知"></a> 最大努力通知</h2>
<p>最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。它在事务主动方增加了消息校对的接口，如果事务被动方没有接收到主动方发送的消息，此时可以调用事务主动方提供的消息校对的接口主动获取</p>
<p><img src="/2023/02/17/javase/image-20230406173526653.png" alt="image-20230406173526653"></p>
<p>​     在可靠消息事务中，事务主动方需要将消息发送出去，并且让接收方成功接收消息，这种可靠性发送是由事务主动方保证的；但是最大努力通知，事务主动方仅仅是尽最大努力（重试，轮询…）将事务发送给事务接收方，所以存在事务被动方接收不到消息的情况，此时需要事务被动方主动调用事务主动方的消息校对接口查询业务消息并消费，这种通知的可靠性是由事务被动方保证的。</p>
<p>​    所以最大努力通知适用于业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口。</p>
<h2 id="各方案常见使用场景"><a class="markdownIt-Anchor" href="#各方案常见使用场景"></a> 各方案常见使用场景</h2>
<ul>
<li><strong>2PC/3PC</strong>：依赖于数据库，能够很好的提供强一致性和强事务性，但延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</li>
<li><strong>TCC</strong>：适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</li>
<li><strong>本地消息表/MQ 事务</strong>：适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。</li>
<li><strong>Saga 事务</strong>：由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。Saga 由于缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。所以，Saga 事务较适用于补偿动作容易处理的场景</li>
</ul>
<h1 id="13其他"><a class="markdownIt-Anchor" href="#13其他"></a> 13.其他</h1>
<p><strong>字符串数据结构在C语言的底层实现，是字节数组吗。</strong></p>
<ul>
<li>jdk1.8及以前String底层使用是char[]，1.9开始使用byte[]</li>
</ul>
<p><strong>原子变量的实现原理</strong></p>
<ul>
<li>底层用到都是cas，类中用了unsafe来实现cas
<ul>
<li>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得</li>
</ul>
</li>
</ul>
<p><strong>有没有更好的计数器解决策略</strong></p>
<ul>
<li>LongAdder</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://cloud-tour.github.io/2023/02/17/javase/" title="javase" target="_blank" rel="external">http://cloud-tour.github.io/2023/02/17/javase/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/Cloud-Tour" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar2.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/Cloud-Tour" target="_blank"><span class="text-dark">Cloud-Tour</span><small class="ml-1x">Development Engineer &amp; Java</small></a></h3>
        <div>A man who wants to float on the cloud</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2023/02/17/juc/" title="juc"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/10/08/debian%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85nginx/" title="debian系统下安装nginx"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button">    <span>[&nbsp;</span><span>Catalogue</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>$</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>Maybe you could buy me a cup of coffee.</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open alipay app scan this qrcode, buy me a coffee!</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open wechat app scan this qrcode, buy me a coffee!</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> alipay</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> wechat payment</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Cloud-Tour" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>