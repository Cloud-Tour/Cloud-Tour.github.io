<!DOCTYPE html>
<html lang=en>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>jvm | Hexo</title>
  <meta name="description" content="一.JVM内存模型及其各部分的作用  从宏观上来说JVM 内存区域 分为三部分线程共享区域、线程私有区域、直接内存区域(上图static变量该在堆区)。  线程共享区域  堆区 堆区Heap是JVM中最大的一块内存区域，基本上所有的对象实例都是在堆上分配空间。堆区细分为年轻代和老年代，其中年轻代又分为Eden、S0、S1 三个部分，他们默认的比例是8:1:1的大小。  元空间 方法区：   在">
<meta property="og:type" content="article">
<meta property="og:title" content="jvm">
<meta property="og:url" content="http://cloud-tour.github.io/2023/02/17/jvm/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一.JVM内存模型及其各部分的作用  从宏观上来说JVM 内存区域 分为三部分线程共享区域、线程私有区域、直接内存区域(上图static变量该在堆区)。  线程共享区域  堆区 堆区Heap是JVM中最大的一块内存区域，基本上所有的对象实例都是在堆上分配空间。堆区细分为年轻代和老年代，其中年轻代又分为Eden、S0、S1 三个部分，他们默认的比例是8:1:1的大小。  元空间 方法区：   在">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dXNxVbkGSYyGbTpyVdnA6qDxZne5WpZnib6lP7IKZpolkHPCd7Wh8vMk6dLUoQQx0TB9DhcjOjeChw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dXNxVbkGSYyGbTpyVdnA6qD9xqr1micZrEG8JtN13Pv1XELtMzhAU0zliaiawiaw0qxaUVia7KvhQXtCPw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dXNxVbkGSYyGbTpyVdnA6qDNaEHVXjrGTGCEpNbaAu69YHyOzJ9beqyvZBQHWbH598R2DbdQORLng/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dXNxVbkGSYyGbTpyVdnA6qDNSzXFuNEtzoFGdF5eToIia5gsdpgoUDUicpJcicvM9N3KlObicY2eRX6LA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dXNxVbkGSYyGbTpyVdnA6qDXG20K10J6v5xl7GXpJvN2WiaKcVaQ33QXQ4I4giaicNu7a1Gv3sicnFKCw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/fd747651b9c6c6a2847c6d84a1e88832.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95-%E9%97%AE%E9%A2%98.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/%E6%94%B6%E9%9B%86%E5%99%A8.jpg">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/Serial%E6%94%B6%E9%9B%86%E5%99%A8.jpg">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.jpg">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/SerialOld%E6%94%B6%E9%9B%86%E5%99%A8.jpg">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/ParallelOld%E6%94%B6%E9%9B%86%E5%99%A8.jpg">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/G1-Region.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14131260-4f531fdccb83fa85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/JVM-%E7%A3%81%E7%9B%98%E4%B8%8D%E8%B6%B3%E6%8E%92%E6%9F%A5.jpg">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/JVM-%E7%A3%81%E7%9B%98%E4%B8%8D%E8%B6%B3%E6%8E%92%E6%9F%A5-du-sh.jpg">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/593998/202108/593998-20210819154844851-2077219236.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/593998/202108/593998-20210819160430741-2012660940.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/593998/202108/593998-20210819161019047-2037837841.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/593998/202108/593998-20210819161218938-471280901.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/593998/202108/593998-20210819161244868-297649295.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/593998/202108/593998-20210819161305681-1001506236.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/593998/202108/593998-20210819161352166-1036294546.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/CPU%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5-top.jpg">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/CPU%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5-top-Hp-pid.jpg">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/CPU%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5-printf.jpg">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/CPU%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5-jstack.jpg">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/OOM%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5-%E6%9F%A5%E7%9C%8B%E5%AE%9E%E4%BE%8B%E6%9C%80%E5%A4%9A%E7%9A%84%E7%B1%BB.jpg">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/OOM%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5-%E6%9F%A5%E7%9C%8B%E5%BC%82%E5%B8%B8%E4%BB%A3%E7%A0%81.jpg">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/OOM%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5-%E6%9F%A5%E7%9C%8B%E5%BC%82%E5%B8%B8%E4%BB%A3%E7%A0%81%E5%A0%86%E6%A0%88.jpg">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/20200119164751943.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/2020011916475242.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/20200119164752266.png">
<meta property="og:image" content="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/20200119164749513.png">
<meta property="article:published_time" content="2023-02-17T13:16:37.239Z">
<meta property="article:modified_time" content="2023-02-17T13:18:43.428Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java">
<meta property="article:tag" content="jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dXNxVbkGSYyGbTpyVdnA6qDxZne5WpZnib6lP7IKZpolkHPCd7Wh8vMk6dLUoQQx0TB9DhcjOjeChw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1">
  <!-- Canonical links -->
  <link rel="canonical" href="http://cloud-tour.github.io/2023/02/17/jvm/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/Cloud-Tour" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar2.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Cloud-Tour</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Development Engineer &amp; Java</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> MaoMing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">Repository</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">Books</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">Links</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">About</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Cloud-Tour" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/">51单片机</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javase/">javase</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/juc/">juc</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm/">jvm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/debian/" rel="tag">debian</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java11/" rel="tag">java11</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/" rel="tag">juc</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/" rel="tag">jvm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keil/" rel="tag">keil</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/proteus/" rel="tag">proteus</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssb/" rel="tag">ssb</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/debian/" style="font-size: 13.5px;">debian</a> <a href="/tags/java/" style="font-size: 14px;">java</a> <a href="/tags/java11/" style="font-size: 13px;">java11</a> <a href="/tags/juc/" style="font-size: 13px;">juc</a> <a href="/tags/jvm/" style="font-size: 13px;">jvm</a> <a href="/tags/keil/" style="font-size: 13px;">keil</a> <a href="/tags/mysql/" style="font-size: 13px;">mysql</a> <a href="/tags/nginx/" style="font-size: 13px;">nginx</a> <a href="/tags/proteus/" style="font-size: 13px;">proteus</a> <a href="/tags/redis/" style="font-size: 13px;">redis</a> <a href="/tags/ssb/" style="font-size: 13px;">ssb</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/redis/">redis</a>
              </p>
              <p class="item-title">
                <a href="/2023/02/17/redis/" class="title">redis</a>
              </p>
              <p class="item-date">
                <time datetime="2023-02-17T13:22:50.541Z" itemprop="datePublished">2023-02-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/mysql/">mysql</a>
              </p>
              <p class="item-title">
                <a href="/2023/02/17/mysql/" class="title">mysql</a>
              </p>
              <p class="item-date">
                <time datetime="2023-02-17T13:21:00.159Z" itemprop="datePublished">2023-02-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/java/">java</a>
              </p>
              <p class="item-title">
                <a href="/2023/02/17/ssb/" class="title">ssb</a>
              </p>
              <p class="item-date">
                <time datetime="2023-02-17T13:19:19.502Z" itemprop="datePublished">2023-02-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/jvm/">jvm</a>
              </p>
              <p class="item-title">
                <a href="/2023/02/17/jvm/" class="title">jvm</a>
              </p>
              <p class="item-date">
                <time datetime="2023-02-17T13:16:37.239Z" itemprop="datePublished">2023-02-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/juc/">juc</a>
              </p>
              <p class="item-title">
                <a href="/2023/02/17/juc/" class="title">juc</a>
              </p>
              <p class="item-date">
                <time datetime="2023-02-17T13:02:02.380Z" itemprop="datePublished">2023-02-17</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%90%84%E9%83%A8%E5%88%86%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text"> 一.JVM内存模型及其各部分的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.1.</span> <span class="toc-text"> 线程共享区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%8C%BA"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 堆区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 元空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.2.</span> <span class="toc-text"> 直接内存区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.3.</span> <span class="toc-text"> 线程私有区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 本地方法栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8Cnew%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text"> 二.new一个对象的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.1.</span> <span class="toc-text"> 类的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">2.1.4.</span> <span class="toc-text"> 解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.5.</span> <span class="toc-text"> 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.6.</span> <span class="toc-text"> 使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD"><span class="toc-number">2.1.7.</span> <span class="toc-text"> 卸载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text"> 三.类的初始化顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text"> 四.类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text"> 双亲委派机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.</span> <span class="toc-text"> 关于加载机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.</span> <span class="toc-text"> 补充问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text"> 五.java程序运行的过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%ADjvm%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text"> 六.JVM跨代引用问题如何处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%A1%E8%A1%A8"><span class="toc-number">6.1.</span> <span class="toc-text"> 卡表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E9%9B%86%E5%90%88"><span class="toc-number">6.2.</span> <span class="toc-text"> 记忆集合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9E%83%E5%9C%BE%E6%98%AF%E5%90%A6%E6%9C%89%E5%BC%95%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text"> 七.判断对象是否为垃圾（是否有引用）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text"> 引用计数法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">7.2.</span> <span class="toc-text"> 可达性分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%ABgc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text"> 八.GC垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">8.1.</span> <span class="toc-text"> 年轻代收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">8.1.1.</span> <span class="toc-text"> Serial收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parnew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">8.1.2.</span> <span class="toc-text"> ParNew收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parallel-scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">8.1.3.</span> <span class="toc-text"> Parallel Scavenge收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">8.2.</span> <span class="toc-text"> 老年代收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#serial-old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">8.2.1.</span> <span class="toc-text"> Serial Old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parallel-old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">8.2.2.</span> <span class="toc-text"> Parallel Old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cms%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">8.2.3.</span> <span class="toc-text"> CMS收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#g1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">8.3.</span> <span class="toc-text"> G1收集器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9Dnew%E5%AF%B9%E8%B1%A1%E6%97%B6%E7%9A%84%E5%A0%86%E6%8A%A2%E5%8D%A0%E9%97%AE%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text"> 九.new对象时的堆抢占问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tlab"><span class="toc-number">9.0.1.</span> <span class="toc-text"> TLAB</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#new%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E"><span class="toc-number">9.0.1.0.1.</span> <span class="toc-text"> new对象与指针碰撞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tlab%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="toc-number">9.0.1.0.2.</span> <span class="toc-text"> TLAB的出现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tlab%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">9.0.1.0.3.</span> <span class="toc-text"> TLAB的缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E4%B8%8A%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.0.2.</span> <span class="toc-text"> 栈上对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81jvm%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">10.</span> <span class="toc-text"> 十.JVM性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E4%B8%8D%E8%B6%B3%E6%8E%92%E6%9F%A5"><span class="toc-number">10.1.</span> <span class="toc-text"> 磁盘不足排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%8E%92%E6%9F%A5%E4%B8%8E%E8%A7%A3%E5%86%B3"><span class="toc-number">10.2.</span> <span class="toc-text"> 堆外内存排查与解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%8E%B0%E8%B1%A1"><span class="toc-number">10.2.1.</span> <span class="toc-text"> 1. 现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A8%A1%E6%8B%9F%E7%A8%8B%E5%BA%8F"><span class="toc-number">10.2.2.</span> <span class="toc-text"> 2. 模拟程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-nmt"><span class="toc-number">10.2.3.</span> <span class="toc-text"> 3. NMT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-pmap"><span class="toc-number">10.2.4.</span> <span class="toc-text"> 4. pmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-gdb"><span class="toc-number">10.2.5.</span> <span class="toc-text"> 5. gdb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-perf"><span class="toc-number">10.2.6.</span> <span class="toc-text"> 6. perf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-gperftools"><span class="toc-number">10.2.7.</span> <span class="toc-text"> 7. gperftools</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%A7%A3%E5%86%B3"><span class="toc-number">10.2.8.</span> <span class="toc-text"> 8. 解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%B0%8F%E7%BB%93"><span class="toc-number">10.2.9.</span> <span class="toc-text"> 9. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5"><span class="toc-number">10.3.</span> <span class="toc-text"> CPU过高排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oom%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5"><span class="toc-number">10.4.</span> <span class="toc-text"> OOM异常排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jvisualvm"><span class="toc-number">10.5.</span> <span class="toc-text"> Jvisualvm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">10.5.1.</span> <span class="toc-text"> 内存问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu%E8%80%97%E6%97%B6%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">10.5.2.</span> <span class="toc-text"> CPU耗时问题排查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="toc-number">10.6.</span> <span class="toc-text"> 调优参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">10.6.1.</span> <span class="toc-text"> 堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">10.6.2.</span> <span class="toc-text"> 栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4-2"><span class="toc-number">10.6.3.</span> <span class="toc-text"> 元空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">10.6.4.</span> <span class="toc-text"> 直接内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%94%B6%E7%BC%A9"><span class="toc-number">10.6.5.</span> <span class="toc-text"> 内存收缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">10.6.6.</span> <span class="toc-text"> 日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc"><span class="toc-number">10.6.7.</span> <span class="toc-text"> GC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#serial%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%96%B0%E7%94%9F%E4%BB%A3"><span class="toc-number">10.6.7.1.</span> <span class="toc-text"> Serial垃圾收集器（新生代）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parallel-scavenge%E6%94%B6%E9%9B%86%E5%99%A8%E6%96%B0%E7%94%9F%E4%BB%A3%E5%BC%80%E5%90%AF"><span class="toc-number">10.6.7.2.</span> <span class="toc-text"> Parallel Scavenge收集器（新生代）开启</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parallelol%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%80%81%E5%B9%B4%E4%BB%A3%E5%BC%80%E5%90%AF"><span class="toc-number">10.6.7.3.</span> <span class="toc-text"> ParallelOl垃圾收集器（老年代）开启</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parnew%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%96%B0%E7%94%9F%E4%BB%A3%E5%BC%80%E5%90%AF"><span class="toc-number">10.6.7.4.</span> <span class="toc-text"> ParNew垃圾收集器（新生代）开启</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cms%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%80%81%E5%B9%B4%E4%BB%A3%E5%BC%80%E5%90%AF"><span class="toc-number">10.6.7.5.</span> <span class="toc-text"> CMS垃圾收集器（老年代）开启</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%BC%80%E5%90%AF"><span class="toc-number">10.6.7.6.</span> <span class="toc-text"> G1垃圾收集器开启</span></a></li></ol></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-jvm" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      jvm
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2023/02/17/jvm/" class="article-date">
	  <time datetime="2023-02-17T13:16:37.239Z" itemprop="datePublished">2023-02-17</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/jvm/">jvm</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/java/" rel="tag">java</a>, <a class="article-tag-link-link" href="/tags/jvm/" rel="tag">jvm</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2023/02/17/jvm/#comments" class="article-comment-link">Comments</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="一jvm内存模型及其各部分的作用"><a class="markdownIt-Anchor" href="#一jvm内存模型及其各部分的作用"></a> 一.JVM内存模型及其各部分的作用</h1>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dXNxVbkGSYyGbTpyVdnA6qDxZne5WpZnib6lP7IKZpolkHPCd7Wh8vMk6dLUoQQx0TB9DhcjOjeChw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>从宏观上来说JVM <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&amp;mid=2247489951&amp;idx=1&amp;sn=07f8d8c9214a524584c7b06be3c1ad4c&amp;scene=21#wechat_redirect">内存区域</a> 分为三部分<code>线程共享区域</code>、<code>线程私有区域</code>、<code>直接内存区域</code>(上图static变量该在堆区)。</p>
<h2 id="线程共享区域"><a class="markdownIt-Anchor" href="#线程共享区域"></a> 线程共享区域</h2>
<h3 id="堆区"><a class="markdownIt-Anchor" href="#堆区"></a> 堆区</h3>
<p>堆区Heap是JVM中最大的一块内存区域，基本上所有的对象实例都是在堆上分配空间。堆区细分为<strong>年轻代</strong>和<strong>老年代</strong>，其中年轻代又分为Eden、S0、S1 三个部分，他们默认的比例是<code>8:1:1</code>的大小。</p>
<h3 id="元空间"><a class="markdownIt-Anchor" href="#元空间"></a> 元空间</h3>
<p><strong>方法区</strong>：</p>
<blockquote>
<ol>
<li>在 《Java虚拟机规范》中只是规定了有<code>方法区</code>这么个<code>概念</code>跟它的<code>作用</code>。<code>HotSpot</code>在JDK8之前 搞了个<code>永久代</code>把这个概念实现了。用来主要存储类信息、常量池、静态变量、JIT编译后的代码等数据。</li>
<li>PermGen(永久代)中类的元数据信息在每次<strong>FullGC</strong>的时候可能会被收集，但成绩很难令人满意。而且为PermGen分配多大的空间因为存储上述多种数据很难确定大小。因此官方在JDK8剔除移除永久代。</li>
</ol>
</blockquote>
<p><strong>元空间</strong>：</p>
<blockquote>
<p>在Java中用<code>永久代</code>来存储类信息，常量，静态变量等数据不是好办法，因为这样很容易造成内存溢出。同时对永久代的性能调优也很困难，因此在JDK8中 把<code>永久代</code>去除了，引入了元空间<strong>metaspace</strong>，原先的class、field等变量放入到metaspace。</p>
</blockquote>
<p><strong>总结</strong>：</p>
<blockquote>
<p><code>元空间的本质和永久代类似，都是对JVM规范中方法区的实现</code>。不过元空间与永久代之间最大的区别在于：<code>元空间并不在虚拟机中，而是使用本地内存</code>。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过参数来指定元空间的大小。</p>
</blockquote>
<h2 id="直接内存区域"><a class="markdownIt-Anchor" href="#直接内存区域"></a> 直接内存区域</h2>
<p><strong>直接内存</strong>：</p>
<blockquote>
<p>一般使用<strong>Native</strong>函数操作C++代码来实现直接分配堆外内存，不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。这块内存不受Java堆空间大小的限制，但是受本机总内存大小限制所以也会出现OOM异常。分配空间后<strong>避免了在Java堆区跟Native堆中来回复制数据</strong>，可以有效提高读写效率，<strong>但它的创建、销毁却比普通Buffer慢</strong>。</p>
</blockquote>
<p><strong>PS</strong>：如果使用了<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg5MjQ5MzY2Mg==&amp;mid=2247485416&amp;idx=1&amp;sn=fe5ba46a512ce6f845209928f9a885a9&amp;scene=21#wechat_redirect">NIO</a>，本地内存区域会被频繁的使用，此时 jvm内存 ≈ 方法区 ＋ 堆 ＋ 栈＋ 直接内存</p>
<h2 id="线程私有区域"><a class="markdownIt-Anchor" href="#线程私有区域"></a> 线程私有区域</h2>
<p>程序计数器、虚拟机栈、本地方法栈跟线程的生命周期是一样的。</p>
<h3 id="程序计数器"><a class="markdownIt-Anchor" href="#程序计数器"></a> 程序计数器</h3>
<p>课堂上比如你正在看小说《诛仙》，看到1412章节时，老师喊你回答问题，这个时候你肯定要先应付老师的问题，回答完毕后继续接着看，这个时候你可以用书签也可以凭借记忆记住自己在看的位置，通过这样实现继续阅读。</p>
<p>落实到代码运行时候同样道理，<strong>程序计数器</strong>用于记录当前线程下虚拟机正在执行的字节码的指令地址。它具有如下特性：</p>
<p>线程私有</p>
<blockquote>
<p>多线程情况下，在同一时刻所以为了让线程切换后依然能恢复到原位，每条线程都需要有各自独立的程序计数器。</p>
</blockquote>
<p>没有规定OutOfMemoryError</p>
<blockquote>
<p>程序计数器存储的是字节码文件的行号，而这个范围是可知晓的，在一开始分配内存时就可以分配一个绝对不会溢出的内存。</p>
</blockquote>
<p>执行Native方法时值为空</p>
<blockquote>
<p><strong>Native</strong>方法大多是通过C实现并未编译成需要执行的字节码指令，也就不需要去存储字节码文件的行号了。</p>
</blockquote>
<h3 id="虚拟机栈"><a class="markdownIt-Anchor" href="#虚拟机栈"></a> 虚拟机栈</h3>
<p>方法的出入栈：调用的方法会被打包成<strong>栈桢</strong>，一个栈桢至少需要包含一个局部变量表、操作数栈、桢数据区、动态链接。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dXNxVbkGSYyGbTpyVdnA6qD9xqr1micZrEG8JtN13Pv1XELtMzhAU0zliaiawiaw0qxaUVia7KvhQXtCPw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt="JAVA虚拟机栈"></p>
<p><strong>动态链接</strong>：</p>
<blockquote>
<p>当栈帧内部包含一个指向运行时常量池引用前提下，类加载时候会进行符号引用到直接引用的解析跟链接替换。</p>
</blockquote>
<p><strong>局部变量表</strong>：</p>
<blockquote>
<p>局部变量表是栈帧重要组中部分之一。他主要保存函数的参数以及局部的变量信息。局部变量表中的变量作用域是当前调用的函数。函数调用结束后，随着函数栈帧的销毁。局部变量表也会随之销毁，释放空间。</p>
</blockquote>
<p><strong>操作数栈</strong>：</p>
<blockquote>
<p>保存着Java虚拟机执行过程中数据</p>
</blockquote>
<p><strong>方法返回地址</strong>：</p>
<blockquote>
<p>方法被调用的位置，当方法退出时候实际上等同于当前栈帧出栈。</p>
</blockquote>
<h3 id="本地方法栈"><a class="markdownIt-Anchor" href="#本地方法栈"></a> 本地方法栈</h3>
<p>跟虚拟机栈类似，只是为使用到的Native方法服务而已。</p>
<h1 id="二new一个对象的过程"><a class="markdownIt-Anchor" href="#二new一个对象的过程"></a> 二.new一个对象的过程</h1>
<p>一个Java类从编码到最终完成执行，主要包括两个过程，编译、运行。</p>
<blockquote>
<p>编译：将我们写好的.java文件通过Javac命令编译成.class文件。</p>
<p>运行：把编译生成的.class文件交由JVM执行。</p>
</blockquote>
<p>Jvm运行class类的时候，并不是一次性将所有的类都加载到内存中，<strong>而是用到哪个就加载哪个，并且只加载一次</strong>。</p>
<h2 id="类的生命周期"><a class="markdownIt-Anchor" href="#类的生命周期"></a> 类的生命周期</h2>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dXNxVbkGSYyGbTpyVdnA6qDNaEHVXjrGTGCEpNbaAu69YHyOzJ9beqyvZBQHWbH598R2DbdQORLng/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h3 id="加载"><a class="markdownIt-Anchor" href="#加载"></a> 加载</h3>
<p>加载指的是把class字节码文件从各个来源通过类加载器装载入内存中，这里有两个重点：</p>
<blockquote>
<ol>
<li><strong>字节码来源</strong>：一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译</li>
<li><strong>类加载器</strong>：一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器(加密解密那种)。</li>
</ol>
</blockquote>
<ol>
<li>
<p>将类的字节码载入方法区，并创建类.class 对象</p>
</li>
<li>
<p>如果此类的父类没有加载，先加载父类</p>
</li>
<li>
<p>加载是懒惰执行</p>
</li>
</ol>
<h3 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h3>
<p>主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<h3 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h3>
<p>给类静态变量分配内存空间，仅仅是分配空间，比如 public static int age = 14，在准备后age = 0，在初始化阶段 age = 14，如果添加了<strong>final</strong>则在这个阶段直接赋值为14。</p>
<h3 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h3>
<p>将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dXNxVbkGSYyGbTpyVdnA6qDNSzXFuNEtzoFGdF5eToIia5gsdpgoUDUicpJcicvM9N3KlObicY2eRX6LA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3>
<p>前面在加载类阶段用户应用程序可以通过<strong>自定义类加载器</strong>参与之外 其余动作完全由虚拟机主导和控制。此时才是真正开始执行类中定义的代码 ：静态代码块、static 修饰的变量赋值、static final 修饰的<strong>引用类型</strong>变量赋值，会被合并成一个 <code>&lt;cinit&gt;</code> 方法，在初始化时被调用，如果存在父类，先对父类进行初始化。</p>
<h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3>
<p>类加载完毕后紧接着就是为对象分配内存空间和初始化了：</p>
<blockquote>
<ol>
<li>为对象分配合适大小的内存空间</li>
<li>为实例变量赋默认值</li>
<li>设置对象的头信息，对象hash码、GC分代年龄、元数据信息等</li>
<li>执行构造函数(init)初始化。</li>
</ol>
</blockquote>
<h3 id="卸载"><a class="markdownIt-Anchor" href="#卸载"></a> 卸载</h3>
<p>最终没啥说等，就是通过GC算法回收对象了。</p>
<h1 id="三类的初始化顺序"><a class="markdownIt-Anchor" href="#三类的初始化顺序"></a> 三.类的初始化顺序</h1>
<p><strong>（静态变量、静态初始化块：决于它们在类中出现的先后顺序）&gt;（变量、初始化块：决于它们在类中出现的先后顺序）&gt;构造器</strong><br>
<strong>原理：</strong><br>
1、加载类信息。在实例化对象之前，类的装载器会找到需要加载的类class文件，进行类的加载（有父类的会先加载父类），一旦加载到最根上的基类，就会对基类的静态变量和静态初始化块进行初始化；<br>
2、当所有类信息加载完毕就会执行main（）主方法，然后执行new class（），对类进行实例化，首先对变量和、初始化块以及类的构造函数进行初始化（有父类的首先会对父类进行初始化，多个父类递归的方式）<br>
有父类的加载顺序：</p>
<ul>
<li>父类–静态变量</li>
<li>父类–静态初始化块</li>
<li>子类–静态变量</li>
<li>子类–静态初始化块</li>
<li>父类–变量</li>
<li>父类–初始化块</li>
<li>父类–构造器</li>
<li>子类–变量</li>
<li>子类–初始化块</li>
<li>子类–构造器</li>
</ul>
<h1 id="四类加载器"><a class="markdownIt-Anchor" href="#四类加载器"></a> 四.类加载器</h1>
<p>在连接阶段一般是无法干预的，大部分干预 <strong>类加载阶段</strong>，<code>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性</code>，类加载时候重要三个方法：</p>
<blockquote>
<p>1、<strong>loadClass()</strong> ：加载目标类的入口，它首先会查找当前 ClassLoader 以及它的双亲里面是否已经加载了目标类，找到直接返回</p>
<p>2、<strong>findClass()</strong> ：如果没有找到就会让双亲尝试加载，如果双亲都加载不了，就会调用 findClass() 让自定义加载器自己来加载目标类</p>
<p>3、<strong>defineClass()</strong> ：拿到这个字节码之后再调用 defineClass() 方法将字节码转换成 Class 对象。</p>
</blockquote>
<h2 id="双亲委派机制"><a class="markdownIt-Anchor" href="#双亲委派机制"></a> 双亲委派机制</h2>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dXNxVbkGSYyGbTpyVdnA6qDXG20K10J6v5xl7GXpJvN2WiaKcVaQ33QXQ4I4giaicNu7a1Gv3sicnFKCw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><strong>定义</strong>：</p>
<blockquote>
<p>当某个类加载器需要加载某个.class文件时，首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。</p>
</blockquote>
<p><strong>作用</strong>：</p>
<blockquote>
<p>1、<strong>可以防止重复加载同一个.class</strong>。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。</p>
<p>2、<strong>保证核心*.class不能被篡改</strong>，通过委托方式，不会去篡改核心.class。’</p>
</blockquote>
<p><strong>类加载器</strong>：</p>
<blockquote>
<p>1、BootstrapClassLoader（启动类加载器）：c++编写，加载java核心库 java.*，JAVA_HOME/lib</p>
<p>2、ExtClassLoader （标准扩展类加载器）：java编写的加载扩展库，JAVA_HOME/lib/ext</p>
<p>3、AppClassLoader（系统类加载器）：加载程序所在的目录，如user.dir所在的位置的ClassPath</p>
<p>4、CustomClassLoader（用户自定义类加载器）：用户自定义的类加载器,可加载指定路径的class文件</p>
</blockquote>
<h2 id="关于加载机制"><a class="markdownIt-Anchor" href="#关于加载机制"></a> 关于加载机制</h2>
<p><code>双亲委派机制只是Java类加载的一种常见模式</code>，还有别的加载机制哦，比如<strong>Tomcat</strong> 总是先尝试去加载某个类，如果找不到再用上一级的加载器，跟双亲加载器顺序<strong>正好相反</strong>。再比如当使用第三方框架<strong>JDBC</strong>跟具体实现的时候，反而会引发错误，因为JDK自带的<strong>JDBC</strong>接口由<strong>启动类</strong>加载，而第三方实现接口由<strong>应用类</strong>加载。这样相互之间是不认识的，因此JDK引入了<strong>SPI</strong>机制 线程上下文加载器 来实现加载(跟<strong>Dubbo</strong>的<strong>SPI</strong>不一样哦)。</p>
<h2 id="补充问题"><a class="markdownIt-Anchor" href="#补充问题"></a> 补充问题</h2>
<p><strong>同一个类能被不同的类加载器加载吗？</strong></p>
<p>答：可以加载，虽然类的全限定名一致，但是如果由不同的类加载器加载后，在jvm中会被认为是两个不同的类。这是由于类加载器的单一性，虽然父类型的加载器对于子类加载器是可见的，但是类加载器“邻居”之间，同一类型仍然可以被加载多次，因为相互不可见。</p>
<p><strong>怎么判定两个class是相同的？</strong></p>
<p>答：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。</p>
<h1 id="五java程序运行的过程"><a class="markdownIt-Anchor" href="#五java程序运行的过程"></a> 五.java程序运行的过程</h1>
<ol>
<li>创建 JVM，调用类加载子系统加载 class，将类的信息存入<strong>方法区</strong></li>
<li>创建 main 线程，使用的内存区域是 <strong>JVM 虚拟机栈</strong>，开始执行 main 方法代码</li>
<li>如果遇到了未见过的类，会继续触发类加载过程，同样会存入<strong>方法区</strong></li>
<li>需要创建对象，会使用<strong>堆</strong>内存来存储对象</li>
<li>不再使用的对象，会由<strong>垃圾回收器</strong>在内存不足时回收其内存</li>
<li>调用方法时，方法内的局部变量、方法参数所使用的是  <strong>JVM 虚拟机栈</strong>中的栈帧内存</li>
<li>调用方法时，先要到<strong>方法区</strong>获得到该方法的字节码指令，由<strong>解释器</strong>将字节码指令解释为机器码执行</li>
<li>调用方法时，会将要执行的指令行号读到<strong>程序计数器</strong>，这样当发生了线程切换，恢复时就可以从中断的位置继续</li>
<li>对于非 java 实现的方法调用，使用内存称为<strong>本地方法栈</strong>（见说明）</li>
<li>对于热点方法调用，或者频繁的循环代码，由 <strong>JIT 即时编译器</strong>将这些代码编译成机器码缓存，提高执行性能</li>
</ol>
<h1 id="六jvm跨代引用问题如何处理"><a class="markdownIt-Anchor" href="#六jvm跨代引用问题如何处理"></a> 六.JVM跨代引用问题如何处理</h1>
<p><strong>跨代引用</strong></p>
<ul>
<li><strong>场景：</strong><br>
年轻代的对象持有着老年代对象的引用、老年代的对象持有着年轻代对象的引用</li>
<li><strong>特点：</strong><br>
互相引用的两个对象几乎总是同生共死：<br>
如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生对象在minor gc时得以存活，该对象经历多次minor gc后晋升到老年代，此时跨代引用自然也随着该对象的晋升而消失了。<br>
因此，存在跨代引用的对象较少。</li>
<li><strong>跨代引用带来的问题：</strong><br>
年轻代对象引用老年代对象：minor gc时需要扫描老年代。<br>
老年代对象引用年轻代对象：major gc时需要扫描年轻代。</li>
<li><strong>解决方案：</strong><br>
通过降低扫描对象的范围或数量来降低gc的耗时：
<ul>
<li>年轻代对象引用老年代对象：借助 卡表/记忆集合 来减小minor gc时扫描老年代的范围，进而降低minor gc的时间。<br>
老年代对象引用年轻代对象：<br>
CMS收集器：借助 提前触发minor gc 来减少年轻代中对象的数量，进而降低major gc的时间。<br>
G1收集器：借助 记忆集合 来减少老年代gc时扫描年轻代的范围，进而降低minor gc的时间。</li>
</ul>
</li>
</ul>
<h2 id="卡表"><a class="markdownIt-Anchor" href="#卡表"></a> 卡表</h2>
<ul>
<li>
<p><strong>数据结构：</strong></p>
<ul>
<li>**卡表：**jvm将老年代划分为若干个大小为512字节的区域(card)，并使用一个 <strong>字节(byte)数组</strong> 来标记老年代中这些区域(card)中的对象是否持有新生代对象的引用。jvm将这个 字节数组 称为卡表(card table)。</li>
<li><strong>卡表中的元素</strong>：表示老年代中某块区域(card)中的对象是否持有新生代对象的引用。</li>
<li><strong>卡表</strong>属于points-out(我引用了谁的对象)的结构。</li>
</ul>
<blockquote>
<p>说明：之所以使用byte数组而不是bit数组主要是速度上的考量，现代计算机硬件都是最小按字节寻址的，没有直接存储一个bit指令，所以要用bit的话就不得不多消耗几条shift+mask指令。</p>
</blockquote>
</li>
<li>
<p><strong>原理：</strong></p>
<ul>
<li>当老年代中的某个对象持有了新生代对象的引用时，jvm将卡表中表示该对象所在区域(card)的元素设为1，表示该对象所在区域(card)是一个 dirty card。（注意：新生代对象引用老年代对象时，老年代对象所在的区域(card)不会被标记为dirty card）。</li>
<li>年轻代gc时只扫描dirty card中的对象，而无需扫描整个老年代中的对象，从而减少年轻代gc的停顿时间。</li>
<li>当完成所有脏卡的扫描之后，jvm便会将所有脏卡的标识位清零。</li>
</ul>
</li>
<li>
<p><strong>card标记为dirty card的原理</strong></p>
<ul>
<li><strong>写屏障：</strong>
<ul>
<li>写屏障是一小段将card标记为dirty card的代码：检查对象的引用变更时是否出现了跨代引用(g1是跨region引用)，如果出现，这将对应的card标记为dirty card。</li>
</ul>
</li>
<li><strong>Hotspot VM的字节码解释器和JIT编译器使用写屏障维护卡表：</strong>
<ul>
<li>解释器每次执行更新引用的字节码时，都会执行一段写屏障。</li>
<li>JIT编译器在生成更新引用的代码后，也会生成一段写屏障。</li>
<li>虽然写屏障使得应用线程增加了一些性能开销，但是minor gc的效率提高了很多，进而提高了系统的吞吐量。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="记忆集合"><a class="markdownIt-Anchor" href="#记忆集合"></a> 记忆集合</h2>
<ul>
<li>
<p><strong>数据结构:</strong></p>
<ul>
<li>
<p>每个region都维护着一个记忆集合(Remembered Set / Rset)，收集器在标记跨代引用的对象时只需扫描(CSet中region维护的)RSet即可。</p>
</li>
<li>
<p>RSet的整体结构是一个哈希表，底层是在卡表的基础上实现的。</p>
<ul>
<li>key：key记录了引用本region中对象的对象所在region的位置。</li>
<li>value：是一个集合，其元素是：其它region(由key确定是哪个region)中的对象引用本region中对象的引用及引用所在的卡表位置。</li>
</ul>
</li>
<li>
<p>Rset属于points-into结构(谁引用了我的对象)</p>
</li>
</ul>
</li>
<li>
<p><strong>RSet、Card和Region的关系</strong></p>
<ul>
<li>每个region被分成了多个card。</li>
<li>不同region中的card会相互引用。</li>
<li>图示：<img src="https://img-blog.csdnimg.cn/img_convert/fd747651b9c6c6a2847c6d84a1e88832.png" alt="Remembered Sets"></li>
</ul>
</li>
</ul>
<p>Region1中的Card中的对象引用了Region2中的Card中的对象，蓝色实线表示的就是points-out的关系，而在Region2的RSet中，记录了Region1的Card，即红色虚线表示的关系，这就是points-into。</p>
<h1 id="七判断对象是否为垃圾是否有引用"><a class="markdownIt-Anchor" href="#七判断对象是否为垃圾是否有引用"></a> 七.判断对象是否为垃圾（是否有引用）</h1>
<h2 id="引用计数法"><a class="markdownIt-Anchor" href="#引用计数法"></a> 引用计数法</h2>
<p>引用计数法（Reference Count）会给对象中添加一个引用计数器，每当有一个地方引用它的时候，计数器的值就 +1 ，当引用失效时，计数器值就 -1 ，计数器的值为 0 的对象不可能在被使用，这个时候就可以判定这个对象是垃圾。</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.png" alt="引用计数法"></p>
<p>当图中的数值变成0时，这个时候使用引用计数算法就可以判定它是垃圾了，但是引用计数法不能解决一个问题，就是当对象是循环引用的时候，计数器值都不为0，这个时候引用计数器无法通知GC收集器来回收他们，如下图所示：</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95-%E9%97%AE%E9%A2%98.png" alt="引用计数法-问题"></p>
<p>这个时候就需要使用到我们的根可达算法。</p>
<h2 id="可达性分析"><a class="markdownIt-Anchor" href="#可达性分析"></a> 可达性分析</h2>
<p>根可达算法（Root Searching）的意思是说从根上开始搜索，当一个程序启动后，马上需要的那些个对象就叫做根对象，所谓的根可达算法就是首先找到根对象，然后跟着这根线一直往外找到那些有用的。常见的GC roots如下：</p>
<ul>
<li><strong>线程栈变量：</strong> 第一种是<strong>虚拟机栈中的引用的对象</strong>，在程序中正常创建一个对象，对象会在堆上开辟一块空间，同时会将这块空间的地址作为引用保存到虚拟机栈中，如果对象生命周期结束了，那么引用就会从虚拟机栈中出栈，因此如果在虚拟机栈中有引用，就说明这个对象还是有用的，这种情况是最常见的。</li>
<li><strong>静态变量：<strong>第二种是我们</strong>在类中定义了全局的静态的对象</strong>，也就是使用了<code>static</code>关键字，由于虚拟机栈是线程私有的，所以这种对象的引用会保存在共有的方法区中，显然将方法区中的静态引用作为GC Roots是必须的。</li>
<li><strong>常量池：</strong> 第三种便是<strong>常量引用</strong>，就是使用了<code>static final</code>关键字，由于这种引用初始化之后不会修改，所以方法区常量池里的引用的对象也应该作为GC Roots。</li>
<li><strong>JNI：</strong> 第四种是在使用<strong>JNI</strong>技术时，有时候单纯的Java代码并不能满足我们的需求，我们可能需要在Java中调用C或C++的代码，因此会使用<strong>Native方法</strong>，JVM内存中专门有一块本地方法栈，用来保存这些对象的引用，所以本地方法栈中引用的对象也会被作为GC Roots。</li>
</ul>
<h1 id="八gc垃圾收集器"><a class="markdownIt-Anchor" href="#八gc垃圾收集器"></a> 八.GC垃圾收集器</h1>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="收集器"></p>
<p>GC垃圾收集器的JVM配置参数：</p>
<ul>
<li><strong>-XX:+UseSerialGC</strong>：年轻代和老年代都用串行收集器</li>
<li><strong>-XX:+UseParNewGC</strong>：年轻代使用 ParNew，老年代使用 Serial Old</li>
<li><strong>-XX:+UseParallelGC</strong>：年轻代使用 ParallerGC，老年代使用 Serial Old</li>
<li><strong>-XX:+UseParallelOldGC</strong>：新生代和老年代都使用并行收集器</li>
<li><strong>-XX:+UseConcMarkSweepGC</strong>：表示年轻代使用 ParNew，老年代的用 CMS</li>
<li><strong>-XX:+UseG1GC</strong>：使用 G1垃圾回收器</li>
<li><strong>-XX:+UseZGC</strong>：使用 ZGC 垃圾回收器</li>
</ul>
<h2 id="年轻代收集器"><a class="markdownIt-Anchor" href="#年轻代收集器"></a> 年轻代收集器</h2>
<p>新生代有<code>Serial</code>、<code>ParNew</code>、<code>Parallel Scavenge</code>三种垃圾收集器。</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">串行/并行/并发</th>
<th style="text-align:left">回收算法</th>
<th style="text-align:left">使用场景</th>
<th style="text-align:left">可以跟CMS配合</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Serial</td>
<td style="text-align:left">串行</td>
<td style="text-align:left">复制</td>
<td style="text-align:left">单CPU，Client模式下虚拟机</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">ParNew</td>
<td style="text-align:left">并行(Serial的并行版)</td>
<td style="text-align:left">复制</td>
<td style="text-align:left">多CPU，常在Server模式</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">Parallel Scavenge</td>
<td style="text-align:left">并行</td>
<td style="text-align:left">复制</td>
<td style="text-align:left">多CPU且关注吞吐量</td>
<td style="text-align:left">否</td>
</tr>
</tbody>
</table>
<h3 id="serial收集器"><a class="markdownIt-Anchor" href="#serial收集器"></a> Serial收集器</h3>
<p>处理GC的只有一条线程，并且在垃圾回收的过程中暂停一切用户线程。最简单的垃圾回收器，但千万别以为它没有用武之地。因为简单，所以高效，它通常用在客户端应用上。因为客户端应用不会频繁创建很多对象，用户也不会感觉出明显的卡顿。相反，它使用的资源更少，也更轻量级。</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/Serial%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="Serial收集器"></p>
<h3 id="parnew收集器"><a class="markdownIt-Anchor" href="#parnew收集器"></a> ParNew收集器</h3>
<p>ParNew是Serial的多线程版本。由多条GC线程并行地进行垃圾清理。清理过程依然要停止用户线程。ParNew 追求“低停顿时间”，与 Serial 唯一区别就是使用了多线程进行垃圾收集，在多 CPU 环境下性能比 Serial 会有一定程度的提升；但线程切换需要额外的开销，因此在单 CPU 环境中表现不如 Serial。</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="ParNew收集器"></p>
<h3 id="parallel-scavenge收集器"><a class="markdownIt-Anchor" href="#parallel-scavenge收集器"></a> Parallel Scavenge收集器</h3>
<p>另一个多线程版本的垃圾回收器。它与ParNew的主要区别是：</p>
<ul>
<li><strong>Parallel Scavenge</strong>：追求CPU吞吐量，能够在较短时间完成任务，适合没有交互的后台计算。弱交互强计算</li>
<li><strong>ParNew</strong>：追求降低用户停顿时间，适合交互式应用。强交互弱计算</li>
</ul>
<h2 id="老年代收集器"><a class="markdownIt-Anchor" href="#老年代收集器"></a> 老年代收集器</h2>
<p>老年代有<code>Serial Old</code>、<code>Parallel Old</code>、<code>CMS</code> 三种垃圾收集器。</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">串行/并行/并发</th>
<th style="text-align:left">回收算法</th>
<th style="text-align:left">使用场景</th>
<th style="text-align:left">组合年轻代</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Serial Old</td>
<td style="text-align:left">串行</td>
<td style="text-align:left">标记整理</td>
<td style="text-align:left">单CPU</td>
<td style="text-align:left">Serial  、ParNew、Parallel Scavenge</td>
</tr>
<tr>
<td style="text-align:left">Parallel Old</td>
<td style="text-align:left">并行</td>
<td style="text-align:left">标记整理</td>
<td style="text-align:left">多CPU</td>
<td style="text-align:left">Parallel Scavenge</td>
</tr>
<tr>
<td style="text-align:left">CMS</td>
<td style="text-align:left">并发</td>
<td style="text-align:left">标记清除</td>
<td style="text-align:left">多CPU且关注吞吐量，常用Server端</td>
<td style="text-align:left">Serial 、ParNew</td>
</tr>
</tbody>
</table>
<h3 id="serial-old收集器"><a class="markdownIt-Anchor" href="#serial-old收集器"></a> Serial Old收集器</h3>
<p>与年轻代的 Serial 垃圾收集器对应，都是单线程版本，同样适合客户端使用。年轻代的 Serial，使用复制算法。老年代的 Old Serial，使用<strong>标记-整理</strong>算法。</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/SerialOld%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="SerialOld收集器"></p>
<h3 id="parallel-old收集器"><a class="markdownIt-Anchor" href="#parallel-old收集器"></a> Parallel Old收集器</h3>
<p>Parallel Old 收集器是 Parallel Scavenge 的老年代版本，追求 <strong>CPU 吞吐量</strong>。</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/ParallelOld%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="ParallelOld收集器"></p>
<h3 id="cms收集器"><a class="markdownIt-Anchor" href="#cms收集器"></a> CMS收集器</h3>
<p><strong>并发标记清除(Concurrent Mark Sweep,CMS)垃圾回收器</strong>，是一款致力于获取最短停顿时间的收集器，使用多个线程来扫描堆内存并标记可被清除的对象，然后清除标记的对象。在下面两种情形下会暂停工作线程：</p>
<ul>
<li>在老年代中标记引用对象的时候</li>
<li>在做垃圾回收的过程中堆内存中有变化发生</li>
</ul>
<p>对比与并行垃圾回收器，CMS回收器使用更多的CPU来保证更高的吞吐量。如果我们可以有更多的CPU用来提升性能，那么CMS垃圾回收器是比并行回收器更好的选择。使用 <code>-XX:+UseParNewGCJVM</code> 参数来开启使用CMS垃圾回收器。</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS收集器"></p>
<p><strong>主要流程如下</strong>：</p>
<ul>
<li><strong>初始标记(CMS initial mark)</strong>：仅标记出GC Roots能直接关联到的对象。需要Stop-the-world</li>
<li><strong>并发标记(CMS concurrenr mark)</strong>：进行GC Roots遍历的过程，寻找出所有可达对象</li>
<li><strong>重新标记(CMS remark)</strong>：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。需要Stop-the-world</li>
<li><strong>并发清除(CMS concurrent sweep)</strong>：清出垃圾</li>
</ul>
<p><strong>CMS触发机制</strong>：当老年代的使用率达到80%时，就会触发一次CMS GC。</p>
<ul>
<li><code>-XX:CMSInitiatingOccupancyFraction=80</code></li>
<li><code>-XX:+UseCMSInitiatingOccupancyOnly</code></li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>并发收集</li>
<li>停顿时间最短</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>
<p><strong>并发回收导致CPU资源紧张</strong></p>
<p>在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低程序总吞吐量。CMS默认启动的回收线程数是：（CPU核数 + 3）/ 4，当CPU核数不足四个时，CMS对用户程序的影响就可能变得很大。</p>
</li>
<li>
<p><strong>无法清理浮动垃圾</strong></p>
<p>在CMS的并发标记和并发清理阶段，用户线程还在继续运行，就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留到下一次垃圾收集时再清理掉。这一部分垃圾称为“浮动垃圾”。</p>
</li>
<li>
<p><strong>并发失败（Concurrent Mode Failure）</strong></p>
<p>由于在垃圾回收阶段用户线程还在并发运行，那就还需要预留足够的内存空间提供给用户线程使用，因此CMS不能像其他回收器那样等到老年代几乎完全被填满了再进行回收，必须预留一部分空间供并发回收时的程序运行使用。默认情况下，当老年代使用了 80% 的空间后就会触发 CMS 垃圾回收，这个值可以通过 -XX**😗* CMSInitiatingOccupancyFraction 参数来设置。</p>
<p>这里会有一个风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：Stop The World，临时启用 Serial Old 来重新进行老年代的垃圾回收，这样一来停顿时间就很长了。</p>
</li>
<li>
<p><strong>内存碎片问题</strong></p>
<p>CMS是一款基于“标记-清除”算法实现的回收器，这意味着回收结束时会有内存碎片产生。内存碎片过多时，将会给大对象分配带来麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 Full GC 的情况。</p>
<p>为了解决这个问题，CMS收集器提供了一个 -XX:+UseCMSCompactAtFullCollection 开关参数（默认开启），用于在 Full GC 时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，是无法并发的，这样停顿时间就会变长。还有另外一个参数 -XX:CMSFullGCsBeforeCompaction，这个参数的作用是要求CMS在执行过若干次不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为0，表示每次进入 Full GC 时都进行碎片整理）。</p>
</li>
</ul>
<p><strong>作用内存区域</strong>：老年代</p>
<p><strong>适用场景</strong>：对停顿时间敏感的场合</p>
<p><strong>算法类型</strong>：标记-清除</p>
<h2 id="g1收集器"><a class="markdownIt-Anchor" href="#g1收集器"></a> G1收集器</h2>
<p>G1（Garbage First）回收器采用面向局部收集的设计思路和基于Region的内存布局形式，是一款主要面向服务端应用的垃圾回收器。G1设计初衷就是替换 CMS，成为一种全功能收集器。G1 在JDK9 之后成为服务端模式下的默认垃圾回收器，取代了 Parallel Scavenge 加 Parallel Old 的默认组合，而 CMS 被声明为不推荐使用的垃圾回收器。G1从整体来看是基于 标记-整理 算法实现的回收器，但从局部（两个Region之间）上看又是基于 标记-复制 算法实现的。<strong>G1 回收过程</strong>，G1 回收器的运作过程大致可分为四个步骤：</p>
<ul>
<li><strong>初始标记（会STW）</strong>：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li>
<li><strong>并发标记</strong>：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理在并发时有引用变动的对象。并利用Rset标记跨代引用对象。</li>
<li><strong>最终标记（会STW）</strong>：对用户线程做短暂的暂停，处理并发阶段结束后仍有引用变动的对象。</li>
<li><strong>清理阶段（会STW）</strong>：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条回收器线程并行完成的。</li>
</ul>
<p>G1收集器中的堆内存被划分为多个大小相等的内存块（Region），每个Region是逻辑连续的一段内存，结构如下：</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/G1-Region.png" alt="G1-Region"></p>
<p>每个Region被标记了E、S、O和H，说明每个Region在运行时都充当了一种角色，其中H是以往算法中没有的，它代表Humongous（巨大的），这表示这些Region存储的是巨型对象（humongous object，H-obj），当新建对象大小超过Region大小一半时，直接在新的一个或多个连续Region中分配，并标记为H。</p>
<p>同时G1中引入了<code>RememberSets</code>、<code>CollectionSets</code>帮助更好的执行GC 。</p>
<blockquote>
<p>1、<code>RememberSets</code>： <strong>RSet</strong> 记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）</p>
<p>2、<code>CollectionSets</code>：<strong>Csets</strong> 是一次GC中需要被清理的regions集合，注意G1每次GC不是全部region都参与的，可能只清理少数几个，这几个就被叫做Csets。在GC的时候，对于old -&gt; young 和old -&gt; old的跨代对象引用，只要扫描对应的<strong>CSet</strong>中的<strong>RSet</strong>即可。</p>
</blockquote>
<p>G1进行GC的时候一般分为<code>Yang GC</code>跟<code>Mixed GC</code>。</p>
<blockquote>
<p><code>Young GC</code>：<strong>CSet</strong> 就是所有年轻代里面的Region</p>
<p><code>Mixed GC</code>：<strong>CSet</strong> 是所有年轻代里的Region加上在全局并发标记阶段标记出来的收益高的Region</p>
</blockquote>
<p><strong>Region</strong></p>
<p>堆内存中一个Region的大小可以通过 <code>-XX:G1HeapRegionSize</code>参数指定，大小区间只能是1M、2M、4M、8M、16M和32M，总之是2的幂次方。如果G1HeapRegionSize为默认值，则在堆初始化时计算Region的实际大小，默认把堆内存按照2048份均分，最后得到一个合理的大小。</p>
<p><strong>GC模式</strong></p>
<ul>
<li>
<p><strong>young gc</strong></p>
<p>发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden region被耗尽无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young gc，活跃对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。</p>
<ul>
<li><code>-XX:MaxGCPauseMillis</code>：设置G1收集过程目标时间，默认值<code>200ms</code></li>
<li><code>-XX:G1NewSizePercent</code>：新生代最小值，默认值<code>5%</code></li>
<li><code>-XX:G1MaxNewSizePercent</code>：新生代最大值，默认值<code>60%</code></li>
</ul>
</li>
<li>
<p><strong>mixed gc</strong></p>
<p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制</p>
</li>
<li>
<p><strong>full gc</strong></p>
<ul>
<li>如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc</li>
</ul>
</li>
</ul>
<p><strong>G1垃圾回收器</strong> 应用于大的堆内存空间。它将堆内存空间划分为不同的区域，对各个区域并行地做回收工作。G1在回收内存空间后还立即对空闲空间做整合工作以减少碎片。CMS却是在全部停止(stop the world,STW)时执行内存整合工作。对于不同的区域G1根据垃圾的数量决定优先级。使用 <code>-XX:UseG1GCJVM</code> 参数来开启使用G1垃圾回收器。</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="G1收集器"></p>
<p><strong>主要流程如下</strong>：</p>
<ul>
<li>初始标记(Initial Marking)：标记从GC Root可达的对象。会发生STW</li>
<li>并发标记(Concurrenr Marking)：标记出GC Root可达对象衍生出去的存活对象，并收集各个Region的存活对象信息。整个过程gc collector线程与应用线程可以并行执行</li>
<li><strong>最终标记(Final Marking)</strong>：标记出在并发标记过程中遗漏的，或内部引用发生变化的对象。会发生STW</li>
<li>筛选回收(Live Data Counting And Evacution)：垃圾清除过程，如果发现一个Region中没有存活对象，则把该Region加入到空闲列表中</li>
</ul>
<p><code>-XX:InitiatingHeapOccupancyPercent</code>：当老年代大小占整个堆大小百分比达到该阈值时，会触发一次mixed gc。</p>
<p><strong>回收总结</strong>：</p>
<ul>
<li>
<p>1、经过global concurrent marking，collector就知道哪些Region有存活的对象。并将那些完全可回收的Region(没有存活对象)收集起来加入到可分配Region队列，实现对该部分内存的回收。对于有存活对象的Region，G1会根据统计模型找处收益最高、开销不超过用户指定的上限的若干Region进行对象回收。这些选中被回收的Region组成的集合就叫做collection set 简称Cset！</p>
</li>
<li>
<p>2、在MIX GC中的Cset = <strong>所有年轻代里的region + 根据global concurrent marking统计得出收集收益高的若干old region</strong>。</p>
</li>
<li>
<p>3、在YGC中的Cset = <strong>所有年轻代里的region + 通过控制年轻代的region个数来控制young GC的开销</strong>。</p>
</li>
<li>
<p>4、YGC 与 MIXGC 都是采用多线程复制清理，整个过程会STW。G1的<strong>低延迟原理</strong>在于其回收的区域变得精确并且范围变小了。</p>
</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>1、**并行与并发：**G1能充分利用多CPU、多核环境下的硬件优势，可以通过并发的方式让Java程序继续执行。</li>
<li>2、**分代收集：**分代概念在G1中依然得以保留，它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象来获得更好的收集效果。</li>
<li>3、**空间整合：**G1从整体上看是基于<code>标记-整理</code>算法实现的，从局部(两个Region之间)上看是基于<code>复制算法</code>实现的，G1运行期间不会产生内存空间碎片。</li>
<li>4、**可预测停顿：**G1比CMS牛在能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>需要记忆集来记录新生代和老年代之间的引用关系</li>
<li>需要占用大量的内存，可能达到整个堆内存容量的20%甚至更多</li>
</ul>
<p><strong>作用内存区域</strong>：跨代</p>
<p><strong>适用场景</strong>：作为关注停顿时间的场景的收集器备选方案</p>
<p><strong>算法类型</strong>：整体来看基于”标记-整理算法“，局部采用&quot;复制算法&quot;</p>
<h1 id="九new对象时的堆抢占问题"><a class="markdownIt-Anchor" href="#九new对象时的堆抢占问题"></a> 九.new对象时的堆抢占问题</h1>
<p>问题：jvm 里 new 对象时，堆会不会发生抢占？怎么设计jvm的堆的线程安全？</p>
<h3 id="tlab"><a class="markdownIt-Anchor" href="#tlab"></a> TLAB</h3>
<p>什么是TLAB？它是干什么的？咋们先抛开这个问题，一切的开始得从new对象到指针碰撞开始讲起。</p>
<blockquote>
<h5 id="new对象与指针碰撞"><a class="markdownIt-Anchor" href="#new对象与指针碰撞"></a> new对象与指针碰撞</h5>
</blockquote>
<p>new对象怎么就出问题了呢？<br>
java中我们要创建一个对象,用关键字new就可以了。但是，在我们日常中，有很多生命周期很短的对象。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">dome</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user=<span class="keyword">new</span> <span class="built_in">user</span>();</span><br><span class="line">    user.<span class="built_in">sayhi</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>什么是指针碰撞呢？<br>
假设JVM虚拟机上，堆内存都是规整的。堆内存被一个指针一分为二。指针的左边都被塞满了对象，指针的右变是未使用的区域。每一次有新的对象创建，指针就会向右移动一个对象size的距离。这就被称为指针碰撞。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/14131260-4f531fdccb83fa85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>image</p>
<p>好，问题来了。如果我们多线程执行刚才那个dome方法，一个线程正在给A对象分配内存，<strong><code>指针还没有来的及修改</code></strong>，其它为B对象分配内存的线程，而且还是引用这之前的指针指向。这样就出现毛病了。如果想避免冲突的话,我们可以进行<strong>加锁</strong>,但是加锁会导致性能比较低,因此JVM里没有采用这种方式;</p>
<blockquote>
<h5 id="tlab的出现"><a class="markdownIt-Anchor" href="#tlab的出现"></a> TLAB的出现</h5>
</blockquote>
<p>我们现在已经搞清楚，我们出现了哪些问题。我在为大家介绍一下今天的主角。</p>
<p>TLAB的全称是Thread Local Allocation Buffer，即**<code>线程本地分配缓存区</code>，这是一个线程专用的内存分配区域。**</p>
<p>如果设置了虚拟机参数**<code>-XX:UseTLAB</code><strong>，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样</strong>每个线程都单独拥有一个空间**，如果需要分配内存，就在<strong>自己的空间上分配，这样就不存在竞争的情况</strong>，可以大大提升分配效率。</p>
<p>TLAB空间的内存非常小，缺省情况下仅占有整个Eden空间的1%，也可以通过选项-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小。</p>
<p><strong>TLAB的本质其实是三个<code>指针管理的区域</code></strong>：<code>start</code>，<code>top</code> 和 <code>end</code>，每个线程都会从Eden分配一块空间，例如说100KB，作为自己的TLAB，其中 start 和 end 是占位用的，标识出 eden 里被这个 TLAB 所管理的区域，卡住eden里的一块空间不让其它线程来这里分配。</p>
<p>TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。从这一点看，它被翻译为 线程私有分配区 更为合理一点<br>
当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB，而在老TLAB里的对象还留在原地什么都不用管——它们无法感知自己是否是曾经从TLAB分配出来的，而只关心自己是在eden里分配的。</p>
<blockquote>
<h5 id="tlab的缺点"><a class="markdownIt-Anchor" href="#tlab的缺点"></a> TLAB的缺点</h5>
</blockquote>
<p>事务总不是完美的，TLAB也又自己的缺点。因为<strong>TLAB通常很小，所以<code>放不下大对象</code>。</strong><br>
1，<strong>TLAB空间大小是固定的</strong>，但是这时候一个大对象，我TLAB剩余的空间已经容不下它了。(比如100kb的TLAB，来了个110KB的对象)<br>
2，TLAB空间还剩一点点没有用到，有点舍不得。(比如100kb的TLAB，装了80KB，又来了个30KB的对象)<br>
所以JVM开发人员做了以下处理，设置了最大浪费空间。<br>
当剩余的空间小于最大浪费空间，那该TLAB属于的线程在重新向Eden区申请一个TLAB空间。进行对象创建，还是空间不够，那你这个对象太大了，去Eden区直接创建吧！<br>
当剩余的空间大于最大浪费空间，那这个大对象请你直接去Eden区创建，我TLAB放不下没有使用完的空间。</p>
<p>当然，又回造成新的病垢。<br>
3，Eden空间够的时候，你再次申请TLAB没问题，我不够了，Heap的Eden区要开始GC，<br>
4，TLAB允许浪费空间，导致Eden区空间不连续，积少成多。以后还要人帮忙打理。</p>
<blockquote>
<p>补充:<br>
上面说了对象可能分配到<strong>TLAB</strong>上,其实还可能分配到<strong>栈上</strong>,这涉及到<strong>逃逸分析</strong>以及<strong>标量替换</strong>(<strong>HotSpot中默认就开启这俩</strong>)<br>
关于开启逃逸分析后,确认不会逃逸出方法的对象可以分配到栈上随着方法调用结束而结束,不用走JVM堆处理,可以看<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4fd825568b9e">https://www.jianshu.com/p/4fd825568b9e</a><br>
<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fxiaomingdetianxia%2Farticle%2Fdetails%2F77688945">https://blog.csdn.net/xiaomingdetianxia/article/details/77688945</a></p>
</blockquote>
<h3 id="栈上对象"><a class="markdownIt-Anchor" href="#栈上对象"></a> 栈上对象</h3>
<p>java中我们要创建一个对象,用关键字new就可以了。但是，在我们日常中，有很多生命周期很短的对象。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">dome</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user=<span class="keyword">new</span> <span class="built_in">user</span>();</span><br><span class="line">    user.<span class="built_in">sayhi</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这种对象的作用域都<code>不会逃逸出方法外</code></strong>，也就是说该对象的生命周期会随着方法的调用开始而开始，方法的调用结束而结束。<br>
假设JVM所有的对象都放在堆内存中(为什么用假设，因为JVM并不是这样)一旦方法结束，没有了指向该对象的引用，该对象就需要被GC回收，如果存在很多这样的情况，对GC来说压力山大呀。</p>
<p>如果确定一个对象的作用域不会逃逸出方法之外，那可以将这个对象分配在栈上，这样，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，无须通过垃圾收集器回收，可以减小垃圾收集器的负载。</p>
<p>JVM允许将线程私有的对象打散分配在栈上，而不是分配在堆上。分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统性能。<br>
栈上分配的技术基础：</p>
<ul>
<li>一是**<code>逃逸分析</code>**：逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。</li>
<li>二是**<code>标量替换</code>**：允许将对象打散分配在栈上，比如若一个对象拥有两个字段，会将这两个字段视作局部变量进行分配。</li>
</ul>
<p>只能在server模式下才能启用逃逸分析，参数-XX:DoEscapeAnalysis启用逃逸分析，参数-XX:+EliminateAllocations开启标量替换（默认打开）。Java SE 6u23版本之后，HotSpot中默认就开启了逃逸分析，可以通过选项-XX:+PrintEscapeAnalysis查看逃逸分析的筛选结果。</p>
<h1 id="十jvm性能调优"><a class="markdownIt-Anchor" href="#十jvm性能调优"></a> 十.JVM性能调优</h1>
<h2 id="磁盘不足排查"><a class="markdownIt-Anchor" href="#磁盘不足排查"></a> 磁盘不足排查</h2>
<p>其实，磁盘不足排查算是系统、程序层面的问题排查，并不算是JVM，但是另一方面考虑过来就是，系统磁盘的不足，也会导致JVM的运行异常，所以也把磁盘不足算进来了。并且排查磁盘不足，是比较简单，就是几个命令，然后就是逐层的排查，首先第一个命令就是<strong>df -h</strong>，查询磁盘的状态：</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/JVM-%E7%A3%81%E7%9B%98%E4%B8%8D%E8%B6%B3%E6%8E%92%E6%9F%A5.jpg" alt="JVM-磁盘不足排查"></p>
<p>从上面的显示中其中第一行使用的2.8G最大，然后是挂载在 <strong>/</strong> 目录下，我们直接<strong>cd /</strong>。然后通过执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh *</span><br></pre></td></tr></table></figure>
<p>查看各个文件的大小，找到其中最大的，或者说存储量级差不多的并且都非常大的文件，把那些没用的大文件删除就好。</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/JVM-%E7%A3%81%E7%9B%98%E4%B8%8D%E8%B6%B3%E6%8E%92%E6%9F%A5-du-sh.jpg" alt="JVM-磁盘不足排查-du-sh"></p>
<p>然后，就是直接cd到对应的目录也是执行：du -sh *，就这样一层一层的执行，找到对应的没用的，然后文件又比较大的，可以直接删除。</p>
<h2 id="堆外内存排查与解决"><a class="markdownIt-Anchor" href="#堆外内存排查与解决"></a> 堆外内存排查与解决</h2>
<p>Metaspace 属于堆外内存，但由于它是单独管理的，所以排查起来没什么难度。</p>
<p>你平常可能见到的使用堆外内存的场景还有下面这些：</p>
<ol>
<li>JNI 或者 JNA 程序，直接操纵了本地内存，比如一些加密库；</li>
<li>使用了Java 的 Unsafe 类，做了一些本地内存的操作；</li>
<li>Netty 的直接内存（Direct Memory），底层会调用操作系统的 malloc 函数。</li>
</ol>
<p>使用堆外内存可以调用一些功能完备的库函数，而且减轻了 GC 的压力。</p>
<p>这些代码，有可能是你了解的人写的，也有可能隐藏在第三方的 jar 包里。虽然有一些好处，但是问题排查起来通常会比较的困难。</p>
<p><strong>MaxDirectMemorySize 控制直接内存的申请</strong></p>
<p>其实，通过<strong>这个参数，仍然限制不住所有堆外内存的使用，它只是限制了使用 DirectByteBuffer 的内存申请。</strong></p>
<p>很多时候（比如直接使用了 sun.misc.Unsafe 类），堆外内存会一直增长，直到机器物理内存爆满，被 oom killer。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class UnsafeDemo &#123;</span><br><span class="line">    public static final int _1MB = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        Unsafe unsafe = (Unsafe) field.get(null);</span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码，就会持续申请堆外内存，但它返回的是 long 类型的地址句柄，所以堆内内存的使用会很少。</p>
<p>我们使用下面的命令去限制堆内和直接内存的使用，结果发现程序占用的操作系统内存在一直上升，这两个参数在这种场景下没有任何效果。这段程序搞死了我的机器很多次，运行的时候要小心。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:MaxDirectMemorySize=10M -Xmx10M  UnsafeDemo</span><br></pre></td></tr></table></figure>
<p>相信这种情况也困扰了你，因为使用一些 JDK 提供的工具，根本无法发现这部分内存的使用。</p>
<p>我们需要一些更加底层的工具来发现这些游离的内存分配。</p>
<p>其实，很多内存和性能问题，都逃不过下面要介绍的这些工具的联合分析。本课时将会结合一个实际的例子，来看一下一个堆外内存的溢出情况，了解常见的套路。</p>
<h3 id="1-现象"><a class="markdownIt-Anchor" href="#1-现象"></a> 1. 现象</h3>
<p>我们有一个服务，非常的奇怪，在某个版本之后，占用的内存开始增长，直到虚拟机分配的内存上限，但是并不会 OOM。</p>
<p>如果你开启了 SWAP，会发现这个应用也会毫不犹豫的将它吞掉，有多少吞多少。</p>
<p>说它的内存增长，是通过 top 命令去观察的，看它的 <strong>RES</strong> 列的数值；反之，如果使用 jmap 命令去看内存占用，得到的只是堆的大小，只能看到一小块可怜的空间。</p>
<p><img src="https://img2020.cnblogs.com/blog/593998/202108/593998-20210819154844851-2077219236.png" alt="img"></p>
<p>使用 ps 也能看到相同的效果。我们观测到，除了虚拟内存比较高，达到了 17GB 以外，实际使用的内存 RSS 也夸张的达到了 7 GB，远远超过了 -Xmx 的设定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root]$ ps -p 75 -o rss,vsz  </span><br><span class="line">RSS    VSZ 7152568 17485844</span><br></pre></td></tr></table></figure>
<p>使用 jps 查看启动参数，发现分配了大约 3GB 的堆内存。实际内存使用超出了最大内存设定的一倍还多，这明显是不正常的，肯定是使用了堆外内存。</p>
<h3 id="2-模拟程序"><a class="markdownIt-Anchor" href="#2-模拟程序"></a> 2. 模拟程序</h3>
<p>为了能够使用这些工具实际观测这个内存泄漏的过程，我这里准备了一份小程序。</p>
<p>程序将会持续的使用 Java 的 Zip 函数进行压缩和解压，这种操作在一些对传输性能较高的的场景经常会用到。</p>
<p>程序将会申请 1kb 的随机字符串，然后持续解压。</p>
<p>为了避免让操作系统陷入假死状态，我们每次都会判断操作系统内存使用率，在达到 60% 的时候，我们将挂起程序；通过访问 8888 端口，将会把内存阈值提高到 85%。</p>
<p>我们将分析这两个处于相对静态的虚拟快照。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.management.OperatingSystemMXBean;</span><br><span class="line">import com.sun.net.httpserver.HttpContext;</span><br><span class="line">import com.sun.net.httpserver.HttpServer;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.management.ManagementFactory;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.ThreadLocalRandom;</span><br><span class="line">import java.util.zip.GZIPInputStream;</span><br><span class="line">import java.util.zip.GZIPOutputStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class LeakExample &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 构造随机的字符串</span><br><span class="line">     */</span><br><span class="line">    public static String randomString(int strLength) &#123;</span><br><span class="line">        Random rnd = ThreadLocalRandom.current();</span><br><span class="line">        StringBuilder ret = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; strLength; i++) &#123;</span><br><span class="line">            boolean isChar = (rnd.nextInt(2) % 2 == 0);</span><br><span class="line">            if (isChar) &#123;</span><br><span class="line">                int choice = rnd.nextInt(2) % 2 == 0 ? 65 : 97;</span><br><span class="line">                ret.append((char) (choice + rnd.nextInt(26)));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ret.append(rnd.nextInt(10));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int copy(InputStream input, OutputStream output) throws IOException &#123;</span><br><span class="line">        long count = copyLarge(input, output);</span><br><span class="line">        return count &gt; 2147483647L ? -1 : (int) count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static long copyLarge(InputStream input, OutputStream output) throws IOException &#123;</span><br><span class="line">        byte[] buffer = new byte[4096];</span><br><span class="line">        long count = 0L;</span><br><span class="line"></span><br><span class="line">        int n;</span><br><span class="line">        for (; -1 != (n = input.read(buffer)); count += (long) n) &#123;</span><br><span class="line">            output.write(buffer, 0, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String decompress(byte[] input) throws Exception &#123;</span><br><span class="line">        ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">        copy(new GZIPInputStream(new ByteArrayInputStream(input)), out);</span><br><span class="line">        return new String(out.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static byte[] compress(String str) throws Exception &#123;</span><br><span class="line">        ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">        GZIPOutputStream gzip = new GZIPOutputStream(bos);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            gzip.write(str.getBytes());</span><br><span class="line">            gzip.finish();</span><br><span class="line">            byte[] b = bos.toByteArray();</span><br><span class="line">            return b;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123; gzip.close(); &#125;catch (Exception ex )&#123;&#125;</span><br><span class="line">            try &#123; bos.close(); &#125;catch (Exception ex )&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static OperatingSystemMXBean osmxb = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();</span><br><span class="line"></span><br><span class="line">    public static int memoryLoad() &#123;</span><br><span class="line">        double totalvirtualMemory = osmxb.getTotalPhysicalMemorySize();</span><br><span class="line">        double freePhysicalMemorySize = osmxb.getFreePhysicalMemorySize();</span><br><span class="line"></span><br><span class="line">        double value = freePhysicalMemorySize / totalvirtualMemory;</span><br><span class="line">        int percentMemoryLoad = (int) ((1 - value) * 100);</span><br><span class="line">        return percentMemoryLoad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static volatile int RADIO = 60;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        HttpServer server = HttpServer.create(new InetSocketAddress(8888), 0);</span><br><span class="line">        HttpContext context = server.createContext(&quot;/&quot;);</span><br><span class="line">        context.setHandler(exchange -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                RADIO = 85;</span><br><span class="line">                String response = &quot;OK!&quot;;</span><br><span class="line">                exchange.sendResponseHeaders(200, response.getBytes().length);</span><br><span class="line">                OutputStream os = exchange.getResponseBody();</span><br><span class="line">                os.write(response.getBytes());</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        server.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //1kb</span><br><span class="line">        int BLOCK_SIZE = 1024;</span><br><span class="line">        String str = randomString(BLOCK_SIZE / Byte.SIZE);</span><br><span class="line">        byte[] bytes = compress(str);</span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            int percent = memoryLoad();</span><br><span class="line">            if (percent &gt; RADIO) &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                decompress(bytes);</span><br><span class="line">                Thread.sleep(1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序将使用下面的命令行进行启动。为了简化问题，这里省略了一些无关的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx1G -Xmn1G -XX:+AlwaysPreTouch  -XX:MaxMetaspaceSize=10M -XX:MaxDirectMemorySize=10M -XX:NativeMemoryTracking=detail LeakExample</span><br></pre></td></tr></table></figure>
<h3 id="3-nmt"><a class="markdownIt-Anchor" href="#3-nmt"></a> 3. NMT</h3>
<p>首先介绍一下上面的几个 JVM 参数，分别使用 <strong>Xmx、MaxMetaspaceSize、MaxDirectMemorySize</strong> 这三个参数限制了堆、元空间、直接内存的大小。</p>
<p>然后，使用 <strong>AlwaysPreTouch</strong> 参数：</p>
<ul>
<li>作用 服务启动的时候<strong>真实的分配物理内存给jvm</strong>。默认情况下，通过参数指定了 JVM 大小，只有在 JVM 真正使用的时候，才会分配给它。</li>
<li>如果没有此参数，则jvm启动的时候，分配的只是虚拟内存，当真正使用的时候才会分配物理内存</li>
<li>如果没有此参数，则代码运行的时候，实时分配物理内存，导致代码运行速度变慢</li>
<li>如果有此参数，则jvm启动的时候速度会下降很多</li>
</ul>
<p>在堆比较大的时候，会加大启动时间，但在这个场景中，我们为了减少内存动态分配的影响，把这个值设置为 True。</p>
<p>接下来的 NativeMemoryTracking，是用来追踪 Native 内存的使用情况。通过在启动参数上加入 <strong>-XX:NativeMemoryTracking=detail</strong> 就可以启用。使用 jcmd 命令，就可查看内存分配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd $pid  VM.native_memory summary</span><br></pre></td></tr></table></figure>
<p>我们在一台 <strong>4GB</strong> 的虚拟机上使用上面的命令。启动程序之后，发现进程使用的内存迅速升到 <strong>2.4GB</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># jcmd 2154  VM.native_memory summary</span><br><span class="line">2154:</span><br><span class="line">Native Memory Tracking:</span><br><span class="line"></span><br><span class="line">Total: reserved=2370381KB, committed=1071413KB</span><br><span class="line">-                 Java Heap (reserved=1048576KB, committed=1048576KB)</span><br><span class="line">                            (mmap: reserved=1048576KB, committed=1048576KB)</span><br><span class="line"></span><br><span class="line">-                     Class (reserved=1056899KB, committed=4995KB)</span><br><span class="line">                            (classes #432)</span><br><span class="line">                            (malloc=131KB #328)</span><br><span class="line">                            (mmap: reserved=1056768KB, committed=4864KB)</span><br><span class="line"></span><br><span class="line">-                    Thread (reserved=10305KB, committed=10305KB)</span><br><span class="line">                            (thread #11)</span><br><span class="line">                            (stack: reserved=10260KB, committed=10260KB)</span><br><span class="line">                            (malloc=34KB #52)</span><br><span class="line">                            (arena=12KB #18)</span><br><span class="line"></span><br><span class="line">-                      Code (reserved=249744KB, committed=2680KB)</span><br><span class="line">                            (malloc=144KB #502)</span><br><span class="line">                            (mmap: reserved=249600KB, committed=2536KB)</span><br><span class="line"></span><br><span class="line">-                        GC (reserved=2063KB, committed=2063KB)</span><br><span class="line">                            (malloc=7KB #80)</span><br><span class="line">                            (mmap: reserved=2056KB, committed=2056KB)</span><br><span class="line"></span><br><span class="line">-                  Compiler (reserved=138KB, committed=138KB)</span><br><span class="line">                            (malloc=8KB #38)</span><br><span class="line">                            (arena=131KB #5)</span><br><span class="line"></span><br><span class="line">-                  Internal (reserved=789KB, committed=789KB)</span><br><span class="line">                            (malloc=757KB #1272)</span><br><span class="line">                            (mmap: reserved=32KB, committed=32KB)</span><br><span class="line"></span><br><span class="line">-                    Symbol (reserved=1535KB, committed=1535KB)</span><br><span class="line">                            (malloc=983KB #114)</span><br><span class="line">                            (arena=552KB #1)</span><br><span class="line"></span><br><span class="line">-    Native Memory Tracking (reserved=159KB, committed=159KB)</span><br><span class="line">                            (malloc=99KB #1399)</span><br><span class="line">                            (tracking overhead=60KB)</span><br><span class="line"></span><br><span class="line">-               Arena Chunk (reserved=174KB, committed=174KB)</span><br><span class="line">                            (mall</span><br></pre></td></tr></table></figure>
<p>可惜的是，这个名字让人振奋的工具并不能如它描述的一样，看到我们这种泄漏的场景。下图这点小小的空间，是不能和 2GB 的内存占用相比的。</p>
<p><img src="https://img2020.cnblogs.com/blog/593998/202108/593998-20210819160430741-2012660940.png" alt="img"></p>
<p>NMT 能看到堆内内存、Code 区域或者使用 unsafe.allocateMemory 和 DirectByteBuffer 申请的堆外内存，虽然是个好工具但问题并不能解决。</p>
<p>使用 jmap 工具，dump 一份堆快照，然后使用 MAT 分析，依然不能找到这部分内存。</p>
<h3 id="4-pmap"><a class="markdownIt-Anchor" href="#4-pmap"></a> 4. pmap</h3>
<p>像是 EhCache 这种缓存框架，提供了多种策略，可以设定将数据存储在非堆上，我们就是要排查这些影响因素。</p>
<p>如果能够在代码里看到这种可能性最大的代码块，是最好的。</p>
<p>为了进一步分析问题，我们使用 <strong>pmap</strong> 命令查看进程的内存分配，通过 RSS 升序序排列。</p>
<p>结果发现除了地址 00000000c0000000 上分配的 1GB 堆以外（也就是我们的堆内存），还有数量非常多的 64M 一块的内存段，还有巨量小的物理内存块映射到不同的虚拟内存段上。</p>
<p>但到现在为止，我们不知道里面的内容是什么，是通过什么产生的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># pmap -x 2154  | sort -n -k3</span><br><span class="line">Address           Kbytes     RSS   Dirty Mode  Mapping</span><br><span class="line">---------------- ------- ------- -------</span><br><span class="line">0000000100080000 1048064       0       0 -----   [ anon ]</span><br><span class="line">00007f2d4fff1000      60       0       0 -----   [ anon ]</span><br><span class="line">00007f2d537fb000    8212       0       0 -----   [ anon ]</span><br><span class="line">00007f2d57ff1000      60       0       0 -----   [ anon ]</span><br><span class="line">.....省略N行</span><br><span class="line">00007f2e3c000000   65524   22064   22064 rw---   [ anon ]</span><br><span class="line">00007f2e00000000   65476   22068   22068 rw---   [ anon ]</span><br><span class="line">00007f2e18000000   65476   22072   22072 rw---   [ anon ]</span><br><span class="line">00007f2e30000000   65476   22076   22076 rw---   [ anon ]</span><br><span class="line">00007f2dc0000000   65520   22080   22080 rw---   [ anon ]</span><br><span class="line">00007f2dd8000000   65520   22080   22080 rw---   [ anon ]</span><br><span class="line">00007f2da8000000   65524   22088   22088 rw---   [ anon ]</span><br><span class="line">00007f2e8c000000   65528   22088   22088 rw---   [ anon ]</span><br><span class="line">00007f2e64000000   65520   22092   22092 rw---   [ anon ]</span><br><span class="line">00007f2e4c000000   65520   22096   22096 rw---   [ anon ]</span><br><span class="line">00007f2e7c000000   65520   22096   22096 rw---   [ anon ]</span><br><span class="line">00007f2ecc000000   65520   22980   22980 rw---   [ anon ]</span><br><span class="line">00007f2d84000000   65476   23368   23368 rw---   [ anon ]</span><br><span class="line">00007f2d9c000000  131060   43932   43932 rw---   [ anon ]</span><br><span class="line">00007f2d50000000   57324   56000   56000 rw---   [ anon ]</span><br><span class="line">00007f2d4c000000   65476   64160   64160 rw---   [ anon ]</span><br><span class="line">00007f2d5c000000   65476   64164   64164 rw---   [ anon ]</span><br><span class="line">00007f2d64000000   65476   64164   64164 rw---   [ anon ]</span><br><span class="line">00007f2d54000000   65476   64168   64168 rw---   [ anon ]</span><br><span class="line">00007f2d7c000000   65476   64168   64168 rw---   [ anon ]</span><br><span class="line">00007f2d60000000   65520   64172   64172 rw---   [ anon ]</span><br><span class="line">00007f2d6c000000   65476   64172   64172 rw---   [ anon ]</span><br><span class="line">00007f2d74000000   65476   64172   64172 rw---   [ anon ]</span><br><span class="line">00007f2d78000000   65520   64176   64176 rw---   [ anon ]</span><br><span class="line">00007f2d68000000   65520   64180   64180 rw---   [ anon ]</span><br><span class="line">00007f2d80000000   65520   64184   64184 rw---   [ anon ]</span><br><span class="line">00007f2d58000000   65520   64188   64188 rw---   [ anon ]</span><br><span class="line">00007f2d70000000   65520   64192   64192 rw---   [ anon ]</span><br><span class="line">00000000c0000000 1049088 1049088 1049088 rw---   [ anon ]</span><br><span class="line">total kB         8492740 3511008 3498584</span><br></pre></td></tr></table></figure>
<p>通过 Google，找到以下资料 Linux glibc &gt;= 2.10 (RHEL 6) malloc may show excessive virtual memory usage) 。</p>
<p>文章指出造成应用程序大量申请 64M 大内存块的原因是由 Glibc 的一个版本升级引起的，通过 export MALLOC_ARENA_MAX=4 可以解决 VSZ 占用过高的问题。</p>
<p>虽然这也是一个问题，但却不是我们想要的，因为我们增长的是物理内存，而不是虚拟内存，程序在这一方面表现是正常的。</p>
<h3 id="5-gdb"><a class="markdownIt-Anchor" href="#5-gdb"></a> 5. gdb</h3>
<p>非常好奇 64M 或者其他小内存块中是什么内容，接下来可以通过 gdb 工具将其 dump 出来。</p>
<p>读取 /proc 目录下的 maps 文件，能精准地知晓目前进程的内存分布。</p>
<p>以下脚本通过传入进程 id，能够将所关联的内存全部 dump 到文件中。</p>
<p><strong>注意，这个命令会影响服务，要慎用。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid=$1;grep rw-p /proc/$pid/maps | sed -n &#x27;s/^([0-9a-f]*)-([0-9a-f]*) .*$/1 2/p&#x27; | while read start stop; do gdb --batch --pid $pid -ex &quot;dump memory $1-$start-$stop.dump 0x$start 0x$stop&quot;; done</span><br></pre></td></tr></table></figure>
<p>这个命令十分霸道，甚至把加载到内存中的 class 文件、堆文件一块给 dump 下来。这是机器的原始内存，大多数文件我们打不开。</p>
<p><img src="https://img2020.cnblogs.com/blog/593998/202108/593998-20210819161019047-2037837841.png" alt="img"></p>
<p>更多时候，只需要 dump 一部分内存就可以。再次提醒操作会影响服务，注意 dump 的内存块大小，线上一定要慎用。</p>
<p>我们复制 pman 的一块 64M 内存，比如 00007f2d70000000，然后去掉前面的 0，使用下面代码得到内存块的开始和结束地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/2154/maps | grep 7f2d70000000</span><br><span class="line">7f2d6fff1000-7f2d70000000 ---p 00000000 00:00 0 7f2d70000000-7f2d73ffc000 rw-p 00000000 00:00 0</span><br></pre></td></tr></table></figure>
<p>接下来就 dump 这 64MB 的内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb --batch --pid 2154 -ex &quot;dump memory a.dump 0x7f2d70000000 0x7f2d73ffc000&quot;</span><br></pre></td></tr></table></figure>
<p>使用 du 命令查看具体的内存块大小，不多不少正好 64M。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># du -h a.dump</span><br><span class="line">64M a.dump</span><br></pre></td></tr></table></figure>
<p>是时候查看里面的内容了，使用 strings 命令可以看到内存块里一些可以打印的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># strings -10 a.dump</span><br><span class="line"></span><br><span class="line">0R4f1Qej1ty5GT8V1R8no6T44564wz499E6Y582q2R9h8CC175GJ3yeJ1Q3P5Vt757Mcf6378kM36hxZ5U8uhg2A26T5l7f68719WQK6vZ2BOdH9lH5C7838qf1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>等等？这些内容不应该在堆里面么？为何还会使用额外的内存进行分配？那么还有什么地方在分配堆外内存呢？</p>
<p>这种情况，只可能是 native 程序对堆外内存的操作。</p>
<h3 id="6-perf"><a class="markdownIt-Anchor" href="#6-perf"></a> 6. perf</h3>
<p>下面介绍一个神器 perf，除了能够进行一些性能分析，它还能帮助我们找到相应的 native 调用。这么突出的堆外内存使用问题，肯定能找到相应的调用函数。</p>
<p>使用 perf record -g -p 2154 开启监控栈函数调用，然后访问服务器的 8888 端口，这将会把内存使用的阈值增加到 85%，我们的程序会逐渐把这部分内存占满，你可以手工观察这个过程。</p>
<p>perf 运行一段时间后 Ctrl+C 结束，会生成一个文件 perf.data。</p>
<p>执行 perf report -i perf.data 查看报告。</p>
<p><img src="https://img2020.cnblogs.com/blog/593998/202108/593998-20210819161218938-471280901.png" alt="img"></p>
<p>如图，一般第三方 JNI 程序，或者 JDK 内的模块，都会调用相应的本地函数，在 Linux 上，这些函数库的后缀都是 so。</p>
<p>我们依次浏览用的可疑资源，发现了“<a target="_blank" rel="noopener" href="http://libzip.so">libzip.so</a>”，还发现了不少相关的调用。搜索 zip（输入 / 进入搜索模式），结果如下：</p>
<p><img src="https://img2020.cnblogs.com/blog/593998/202108/593998-20210819161244868-297649295.png" alt="img"></p>
<p>查看 JDK 代码，发现 bzip 大量使用了 native  方法。也就是说，有大量内存的申请和销毁，是在堆外发生的。</p>
<p><img src="https://img2020.cnblogs.com/blog/593998/202108/593998-20210819161305681-1001506236.png" alt="img"></p>
<p>进程调用了Java_java_util_zip_Inflater_inflatBytes() 申请了内存，却没有调用 Deflater 释放内存。与 pmap 内存地址相比对，确实是 zip 在搞鬼。</p>
<h3 id="7-gperftools"><a class="markdownIt-Anchor" href="#7-gperftools"></a> 7. gperftools</h3>
<p>google 还有一个类似的、非常好用的工具，叫做 gperftools，我们主要用到它的 Heap Profiler，功能更加强大。</p>
<p>它的启动方式有点特别，安装成功之后，你只需要输出两个环境变量即可。</p>
<p>mkdir -p /opt/test<br>
export LD_PRELOAD=/usr/lib64/libtcmalloc.so<br>
export HEAPPROFILE=/opt/test/heap</p>
<p>在同一个终端，再次启动我们的应用程序，可以看到内存申请动作都被记录到了 opt 目录下的 test 目录。</p>
<p><img src="https://img2020.cnblogs.com/blog/593998/202108/593998-20210819161352166-1036294546.png" alt="img"></p>
<p>接下来，我们就可以使用 pprof 命令分析这些文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/test</span><br><span class="line">pprof -text *heap  | head -n 200</span><br></pre></td></tr></table></figure>
<p>使用这个工具，能够一眼追踪到申请内存最多的函数。Java_java_util_zip_Inflater_init 这个函数立马就被发现了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Total: 25205.3 MB</span><br><span class="line"> 20559.2  81.6%  81.6%  20559.2  81.6% inflateBackEnd</span><br><span class="line">  4487.3  17.8%  99.4%   4487.3  17.8% inflateInit2_</span><br><span class="line">    75.7   0.3%  99.7%     75.7   0.3% os::malloc@8bbaa0</span><br><span class="line">    70.3   0.3%  99.9%   4557.6  18.1% Java_java_util_zip_Inflater_init</span><br><span class="line">     7.1   0.0% 100.0%      7.1   0.0% readCEN</span><br><span class="line">     3.9   0.0% 100.0%      3.9   0.0% init</span><br><span class="line">     1.1   0.0% 100.0%      1.1   0.0% os::malloc@8bb8d0</span><br><span class="line">     0.2   0.0% 100.0%      0.2   0.0% _dl_new_object</span><br><span class="line">     0.1   0.0% 100.0%      0.1   0.0% __GI__dl_allocate_tls</span><br><span class="line">     0.1   0.0% 100.0%      0.1   0.0% _nl_intern_locale_data</span><br><span class="line">     0.0   0.0% 100.0%      0.0   0.0% _dl_check_map_versions</span><br><span class="line">     0.0   0.0% 100.0%      0.0   0.0% __GI___strdup</span><br><span class="line">     0.0   0.0% 100.0%      0.1   0.0% _dl_map_object_deps</span><br><span class="line">     0.0   0.0% 100.0%      0.0   0.0% nss_parse_service_list</span><br><span class="line">     0.0   0.0% 100.0%      0.0   0.0% __new_exitfn</span><br><span class="line">     0.0   0.0% 100.0%      0.0   0.0% getpwuid</span><br><span class="line">     0.0   0.0% 100.0%      0.0   0.0% expand_dynamic_string_token</span><br></pre></td></tr></table></figure>
<h3 id="8-解决"><a class="markdownIt-Anchor" href="#8-解决"></a> 8. 解决</h3>
<p>这就是我们模拟内存泄漏的整个过程，到此问题就解决了。</p>
<p>GZIPInputStream 使用 Inflater 申请堆外内存、Deflater 释放内存，调用 close() 方法来主动释放。</p>
<p>如果忘记关闭，Inflater 对象的生命会延续到下一次 GC，有一点类似堆内的弱引用。在此过程中，堆外内存会一直增长。</p>
<p>把 decompress 函数改成如下代码，重新编译代码后观察，问题解决。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static String decompress(byte[] input) throws Exception &#123;</span><br><span class="line">        ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">        GZIPInputStream gzip = new GZIPInputStream(new ByteArrayInputStream(input));</span><br><span class="line">        try &#123;</span><br><span class="line">            copy(gzip, out);</span><br><span class="line">            return new String(out.toByteArray());</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try&#123; gzip.close(); &#125;catch (Exception ex)&#123;&#125;</span><br><span class="line">            try&#123; out.close(); &#125;catch (Exception ex)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-小结"><a class="markdownIt-Anchor" href="#9-小结"></a> 9. 小结</h3>
<p>本课时使用了非常多的工具和命令来进行堆外内存的排查，可以看到，除了使用 jmap 获取堆内内存，还对堆外内存的获取也有不少办法。</p>
<p>现在，我们可以把堆外内存进行更加细致地划分了。</p>
<p>元空间属于堆外内存，主要是方法区和常量池的存储之地，使用数“MaxMetaspaceSize”可以限制它的大小，我们也能观测到它的使用。</p>
<p>直接内存主要是通过 DirectByteBuffer 申请的内存，可以使用参数“MaxDirectMemorySize”来限制它的大小（参考第 10 课时）。</p>
<p>其他堆外内存，主要是指使用了 Unsafe 或者其他 JNI 手段直接直接申请的内存。这种情况，就没有任何参数能够阻挡它们，要么靠它自己去释放一些内存，要么等待操作系统对它的审判了。</p>
<p>还有一种情况，和内存的使用无关，但是也会造成内存不正常使用，那就是使用了 Process 接口，直接调用了外部的应用程序，这些程序对操作系统的内存使用一般是不可预知的。</p>
<p>本课时介绍的一些工具，很多高级研发，包括一些面试官，也是不知道的；即使了解这个过程，不实际操作一遍，也很难有深刻的印象。通过这个例子，你可以看到一个典型的堆外内存问题的排查思路。</p>
<p>堆外内存的泄漏是非常严重的，它的排查难度高、影响大，甚至会造成宿主机的死亡。在排查内存问题时，不要忘了这一环。</p>
<h2 id="cpu过高排查"><a class="markdownIt-Anchor" href="#cpu过高排查"></a> CPU过高排查</h2>
<p><strong>排查过程</strong></p>
<ul>
<li>使用<code>top</code>查找进程id</li>
<li>使用<code>top -Hp &lt;pid&gt;</code>查找进程中耗cpu比较高的线程id</li>
<li>使用<code>printf %x &lt;pid&gt;</code>将线程id十进制转十六进制</li>
<li>使用<code> jstack -pid | grep -A 20 &lt;pid&gt;</code>过滤出线程id锁关联的栈信息</li>
<li>根据栈信息中的调用链定位业务代码</li>
</ul>
<p>案例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class CPUSoaring &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">                Thread thread1 = new Thread(new Runnable()&#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                                for (;;)&#123;</span><br><span class="line">                                      System.out.println(&quot;I am children-thread1&quot;);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;,&quot;children-thread1&quot;);</span><br><span class="line">                </span><br><span class="line">                 Thread thread2 = new Thread(new Runnable()&#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                                for (;;)&#123;</span><br><span class="line">                                      System.out.println(&quot;I am children-thread2&quot;);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;,&quot;children-thread2&quot;);</span><br><span class="line">                </span><br><span class="line">                thread1.start();</span><br><span class="line">                thread2.start();</span><br><span class="line">                System.err.println(&quot;I am is main thread!!!!!!!!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>第一步：首先通过<strong>top</strong>命令可以查看到id为<strong>3806</strong>的进程所占的CPU最高：</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/CPU%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5-top.jpg" alt="CPU过高排查-top"></p>
</li>
<li>
<p>第二步：然后通过<strong>top -Hp pid</strong>命令，找到占用CPU最高的线程：</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/CPU%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5-top-Hp-pid.jpg" alt="CPU过高排查-top-Hp-pid"></p>
</li>
<li>
<p>第三步：接着通过：<strong>printf ‘%x\n’ tid</strong>命令将线程的tid转换为十六进制：xid：</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/CPU%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5-printf.jpg" alt="CPU过高排查-printf"></p>
</li>
<li>
<p>第四步：最后通过：<strong>jstack pid|grep xid -A 30</strong>命令就是输出线程的堆栈信息，线程所在的位置：</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/CPU%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5-jstack.jpg" alt="CPU过高排查-jstack"></p>
</li>
<li>
<p>第五步：还可以通过<strong>jstack -l pid &gt; 文件名称.txt</strong> 命令将线程堆栈信息输出到文件，线下查看。</p>
<p>这就是一个CPU飙高的排查过程，目的就是要<strong>找到占用CPU最高的线程所在的位置</strong>，然后就是<strong>review</strong>你的代码，定位到问题的所在。使用Arthas的工具排查也是一样的，首先要使用top命令找到占用CPU最高的Java进程，然后使用Arthas进入该进程内，<strong>使用dashboard命令排查占用CPU最高的线程。</strong>，最后通过<strong>thread</strong>命令线程的信息。</p>
</li>
</ul>
<h2 id="oom异常排查"><a class="markdownIt-Anchor" href="#oom异常排查"></a> OOM异常排查</h2>
<p>OOM的异常排查也比较简单，首先服务上线的时候，要先设置这两个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=$&#123;目录&#125;</span><br></pre></td></tr></table></figure>
<p>指定项目出现OOM异常的时候自动导出堆转储文件，然后通过内存分析工具（<strong>Visual VM</strong>）来进行线下的分析。</p>
<p>首先我们来聊一聊，哪些原因会导致OOM异常，站在JVM的分区的角度：</p>
<ul>
<li><strong>Java堆</strong></li>
<li><strong>方法区</strong></li>
<li><strong>虚拟机栈</strong></li>
<li><strong>本地方法栈</strong></li>
<li><strong>程序计数器</strong></li>
<li><strong>直接内存</strong></li>
</ul>
<p>只有<strong>程序计数器</strong>区域不会出现OOM，在Java 8及以上的<strong>元空间</strong>（本地内存）都会出现OOM。</p>
<p>而站在程序代码的角度来看，总结了大概有以下几点原因会导致OOM异常：</p>
<ul>
<li><strong>内存泄露</strong></li>
<li><strong>对象过大、过多</strong></li>
<li><strong>方法过长</strong></li>
<li><strong>过度使用代理框架，生成大量的类信息</strong></li>
</ul>
<p>接下来我们屋来看看OOM的排查，出现OOM异常后dump出了堆转储文件，然后打开jdk自带的Visual VM工具，导入堆转储文件，首先我使用的OOM异常代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">class OOM &#123;</span><br><span class="line"></span><br><span class="line">        static class User&#123;</span><br><span class="line">                private String name;</span><br><span class="line">                private int age;</span><br><span class="line"></span><br><span class="line">                public User(String name, int age)&#123;</span><br><span class="line">                        this.name = name;</span><br><span class="line">                        this.age = age;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">                List&lt;User&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">                for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                        User user = new User(&quot;zhangsan&quot;+i,i);</span><br><span class="line">                        list.add(user);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，就是往集合里面不断地add对象，带入堆转储文件后，在类和实例那栏就可以看到实例最多的类：</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/OOM%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5-%E6%9F%A5%E7%9C%8B%E5%AE%9E%E4%BE%8B%E6%9C%80%E5%A4%9A%E7%9A%84%E7%B1%BB.jpg" alt="OOM异常排查-查看实例最多的类"></p>
<p>这样就找到导致OOM异常的类，还可以通过下面的方法查看导致OOM异常的线程堆栈信息，找到对应异常的代码段。</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/OOM%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5-%E6%9F%A5%E7%9C%8B%E5%BC%82%E5%B8%B8%E4%BB%A3%E7%A0%81.jpg" alt="OOM异常排查-查看异常代码"></p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/OOM%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5-%E6%9F%A5%E7%9C%8B%E5%BC%82%E5%B8%B8%E4%BB%A3%E7%A0%81%E5%A0%86%E6%A0%88.jpg" alt="OOM异常排查-查看异常代码堆栈"></p>
<p>上面的方法是排查已经出现了OOM异常的方法，肯定是防线的最后一步，那么在此之前怎么防止出现OOM异常呢？</p>
<p>一般大厂都会有自己的监控平台，能够实施的<strong>监控测试环境、预览环境、线上实施的服务健康状况（CPU、内存）</strong> 等信息，对于频繁GC，并且GC后内存的回收率很差的，就要引起我们的注意了。</p>
<p>因为一般方法的长度合理，95%以上的对象都是朝生夕死，在<strong>Minor GC</strong>后只剩少量的存活对象，所以在代码层面上应该避免<strong>方法过长、大对象</strong>的现象。</p>
<p>每次自己写完代码，自己检查后，都可以提交给比自己高级别的工程师<strong>review</strong>自己的代码，就能及时的发现代码的问题，基本上代码没问题，百分之九十以上的问题都能避免，这也是大厂注重代码质量，并且时刻<strong>review</strong>代码的习惯。</p>
<h2 id="jvisualvm"><a class="markdownIt-Anchor" href="#jvisualvm"></a> Jvisualvm</h2>
<p>项目频繁YGC 、FGC问题排查</p>
<h3 id="内存问题"><a class="markdownIt-Anchor" href="#内存问题"></a> 内存问题</h3>
<p>对象内存占用、实例个数监控</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/20200119164751943.png" alt="img"></p>
<p>对象内存占用、年龄值监控</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/2020011916475242.png" alt="img"></p>
<p>通过上面两张图发现这些对象占用内存比较大而且存活时间也是比较常，所以survivor 中的空间被这些对象占用，而如果缓存再次刷新则会创建同样大小对象来替换老数据，这时发现eden内存空间不足，就会触发yonggc 如果yonggc 结束后发现eden空间还是不够则会直接放到老年代，所以这样就产生了大对象的提前晋升，导致fgc增加……</p>
<p><strong>优化办法</strong>：优化两个缓存对象，将缓存对象大小减小。优化一下两个对象，缓存关键信息！</p>
<h3 id="cpu耗时问题排查"><a class="markdownIt-Anchor" href="#cpu耗时问题排查"></a> CPU耗时问题排查</h3>
<p>Cpu使用耗时监控：</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/20200119164752266.png" alt="img"></p>
<p>耗时、调用次数监控：</p>
<p><img src="https://gitee.com/yu120/lemon-guide/raw/main/images/JVM/20200119164749513.png" alt="img"></p>
<p>从上面监控图可以看到主要耗时还是在网络请求，没有看到具体业务代码消耗过错cpu……</p>
<h2 id="调优参数"><a class="markdownIt-Anchor" href="#调优参数"></a> 调优参数</h2>
<h3 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆</h3>
<ul>
<li>-Xms1024m 设置堆的初始大小</li>
<li>-Xmx1024m 设置堆的最大大小</li>
<li>-XX:NewSize=1024m 设置年轻代的初始大小</li>
<li>-XX:MaxNewSize=1024m 设置年轻代的最大值</li>
<li>-XX:SurvivorRatio=8 Eden和S区的比例</li>
<li>-XX:NewRatio=4 设置老年代和新生代的比例</li>
<li>-XX:MaxTenuringThreshold=10 设置晋升老年代的年龄条件</li>
</ul>
<h3 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h3>
<ul>
<li>-Xss128k</li>
</ul>
<h3 id="元空间-2"><a class="markdownIt-Anchor" href="#元空间-2"></a> 元空间</h3>
<ul>
<li>-XX:MetasapceSize=200m 设置初始元空间大小</li>
<li>-XX:MaxMatespaceSize=200m 设置最大元空间大小 默认无限制</li>
</ul>
<h3 id="直接内存"><a class="markdownIt-Anchor" href="#直接内存"></a> 直接内存</h3>
<ul>
<li>-XX:MaxDirectMemorySize 设置直接内存的容量，默认与堆最大值一样</li>
</ul>
<h3 id="内存收缩"><a class="markdownIt-Anchor" href="#内存收缩"></a> 内存收缩</h3>
<ul>
<li>-XX:MaxHeapFreeRatio 空闲内存达到多少比值时，开始收缩JVM进程占用的内存空间。默认应该是70%，若当java进程占用内存过大，该值应该适当调小。</li>
<li>-XX:MinHeapFreeRatio 空闲内存最少保留的比例值。我这里设置的是8%。此参数意思是无论如何进程内存会保留一定比例的空闲内存，进程内存收缩过程中，剩余内存达到这个阈值后，就会停止收缩。</li>
</ul>
<h3 id="日志"><a class="markdownIt-Anchor" href="#日志"></a> 日志</h3>
<ul>
<li>-Xloggc:/opt/app/ard-user/ard-user-gc-%t.log 设置日志目录和日志名称</li>
<li>-XX:+UseGCLogFileRotation 开启滚动生成日志</li>
<li>-XX:NumberOfGCLogFiles=5 滚动GC日志文件数，默认0，不滚动</li>
<li>-XX:GCLogFileSize=20M GC文件滚动大小，需开 UseGCLogFileRotation</li>
<li>-XX:+PrintGCDetails 开启记录GC日志详细信息（包括GC类型、各个操作使用的时间）,并且在程序运行结束打印出JVM的内存占用情况</li>
<li>-XX:+ PrintGCDateStamps 记录系统的GC时间</li>
<li>-XX:+PrintGCCause 产生GC的原因(默认开启)</li>
</ul>
<h3 id="gc"><a class="markdownIt-Anchor" href="#gc"></a> GC</h3>
<h4 id="serial垃圾收集器新生代"><a class="markdownIt-Anchor" href="#serial垃圾收集器新生代"></a> Serial垃圾收集器（新生代）</h4>
<p>开启</p>
<ul>
<li>-XX:+UseSerialGC</li>
</ul>
<p>关闭：</p>
<ul>
<li>-XX:-UseSerialGC //新生代使用Serial 老年代则使用SerialOld</li>
</ul>
<h4 id="parallel-scavenge收集器新生代开启"><a class="markdownIt-Anchor" href="#parallel-scavenge收集器新生代开启"></a> Parallel Scavenge收集器（新生代）开启</h4>
<ul>
<li>-XX:+UseParallelOldGC 关闭</li>
<li>-XX:-UseParallelOldGC 新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器</li>
</ul>
<h4 id="parallelol垃圾收集器老年代开启"><a class="markdownIt-Anchor" href="#parallelol垃圾收集器老年代开启"></a> ParallelOl垃圾收集器（老年代）开启</h4>
<ul>
<li>-XX:+UseParallelGC 关闭</li>
<li>-XX:-UseParallelGC 新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器</li>
</ul>
<h4 id="parnew垃圾收集器新生代开启"><a class="markdownIt-Anchor" href="#parnew垃圾收集器新生代开启"></a> ParNew垃圾收集器（新生代）开启</h4>
<ul>
<li>-XX:+UseParNewGC 关闭</li>
<li>-XX:-UseParNewGC //新生代使用功能ParNew 老年代则使用功能CMS</li>
</ul>
<h4 id="cms垃圾收集器老年代开启"><a class="markdownIt-Anchor" href="#cms垃圾收集器老年代开启"></a> CMS垃圾收集器（老年代）开启</h4>
<ul>
<li>-XX:+UseConcMarkSweepGC 关闭</li>
<li>-XX:-UseConcMarkSweepGC</li>
<li>-XX:MaxGCPauseMillis GC停顿时间，垃圾收集器会尝试用各种手段达到这个时间，比如减小年轻代</li>
<li>-XX:+UseCMSCompactAtFullCollection 用于在CMS收集器不得不进行FullGC时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的</li>
<li>-XX：CMSFullGCsBefore-Compaction 多少次FullGC之后压缩一次，默认值为0，表示每次进入FullGC时都进行碎片整理）</li>
<li>-XX:CMSInitiatingOccupancyFraction 当老年代使用达到该比例时会触发FullGC，默认是92</li>
<li>-XX:+UseCMSInitiatingOccupancyOnly 这个参数搭配上面那个用，表示是不是要一直使用上面的比例触发FullGC，如果设置则只会在第一次FullGC的时候使用-XX:CMSInitiatingOccupancyFraction的值，之后会进行自动调整</li>
<li>-XX:+CMSScavengeBeforeRemark 在FullGC前启动一次MinorGC，目的在于减少老年代对年轻代的引用，降低CMSGC的标记阶段时的开销，一般CMS的GC耗时80%都在标记阶段</li>
<li>-XX:+CMSParallellnitialMarkEnabled 默认情况下初始标记是单线程的，这个参数可以让他多线程执行，可以减少STW</li>
<li>-XX:+CMSParallelRemarkEnabled 使用多线程进行重新标记，目的也是为了减少STW</li>
</ul>
<h4 id="g1垃圾收集器开启"><a class="markdownIt-Anchor" href="#g1垃圾收集器开启"></a> G1垃圾收集器开启</h4>
<ul>
<li>-XX:+UseG1GC 关闭</li>
<li>-XX:-UseG1GC</li>
<li>-XX：G1HeapRegionSize 设置每个Region的大小，取值范围为1MB～32MB</li>
<li>-XX：MaxGCPauseMillis 设置垃圾收集器的停顿时间，默认值是200毫秒，通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的</li>
</ul>
<hr>
<p>堆 gc频次正常 时间正常。 出现内存泄漏是什么问题？</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://cloud-tour.github.io/2023/02/17/jvm/" title="jvm" target="_blank" rel="external">http://cloud-tour.github.io/2023/02/17/jvm/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/Cloud-Tour" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar2.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/Cloud-Tour" target="_blank"><span class="text-dark">Cloud-Tour</span><small class="ml-1x">Development Engineer &amp; Java</small></a></h3>
        <div>A man who wants to float on the cloud</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2023/02/17/ssb/" title="ssb"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2023/02/17/juc/" title="juc"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button">    <span>[&nbsp;</span><span>Catalogue</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>$</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>Maybe you could buy me a cup of coffee.</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open alipay app scan this qrcode, buy me a coffee!</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open wechat app scan this qrcode, buy me a coffee!</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> alipay</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> wechat payment</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Cloud-Tour" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>